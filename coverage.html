
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>v1: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/MommusWinner/MicroDurak/internal/contracts/game/v1/games.pb.go (0.0%)</option>
				
				<option value="file1">github.com/MommusWinner/MicroDurak/internal/contracts/game/v1/games_grpc.pb.go (0.0%)</option>
				
				<option value="file2">github.com/MommusWinner/MicroDurak/internal/contracts/players/v1/players.pb.go (0.0%)</option>
				
				<option value="file3">github.com/MommusWinner/MicroDurak/internal/contracts/players/v1/players_grpc.pb.go (0.0%)</option>
				
				<option value="file4">github.com/MommusWinner/MicroDurak/internal/database/auth.sql.go (0.0%)</option>
				
				<option value="file5">github.com/MommusWinner/MicroDurak/internal/database/db.go (0.0%)</option>
				
				<option value="file6">github.com/MommusWinner/MicroDurak/internal/database/match.sql.go (0.0%)</option>
				
				<option value="file7">github.com/MommusWinner/MicroDurak/internal/database/models.go (0.0%)</option>
				
				<option value="file8">github.com/MommusWinner/MicroDurak/internal/database/player.sql.go (0.0%)</option>
				
				<option value="file9">github.com/MommusWinner/MicroDurak/internal/services/auth/cmd/main.go (0.0%)</option>
				
				<option value="file10">github.com/MommusWinner/MicroDurak/internal/services/auth/connection/auth.go (0.0%)</option>
				
				<option value="file11">github.com/MommusWinner/MicroDurak/internal/services/auth/connection/connection.go (0.0%)</option>
				
				<option value="file12">github.com/MommusWinner/MicroDurak/internal/services/auth/core/ctx.go (0.0%)</option>
				
				<option value="file13">github.com/MommusWinner/MicroDurak/internal/services/auth/core/di.go (0.0%)</option>
				
				<option value="file14">github.com/MommusWinner/MicroDurak/internal/services/auth/core/grpc_players_client.go (0.0%)</option>
				
				<option value="file15">github.com/MommusWinner/MicroDurak/internal/services/auth/core/smtp.go (0.0%)</option>
				
				<option value="file16">github.com/MommusWinner/MicroDurak/internal/services/auth/delivery/http/docs/docs.go (0.0%)</option>
				
				<option value="file17">github.com/MommusWinner/MicroDurak/internal/services/auth/delivery/http/handlers.go (0.0%)</option>
				
				<option value="file18">github.com/MommusWinner/MicroDurak/internal/services/auth/delivery/http/router.go (0.0%)</option>
				
				<option value="file19">github.com/MommusWinner/MicroDurak/internal/services/auth/domain/cases/login.go (0.0%)</option>
				
				<option value="file20">github.com/MommusWinner/MicroDurak/internal/services/auth/domain/cases/register.go (0.0%)</option>
				
				<option value="file21">github.com/MommusWinner/MicroDurak/internal/services/auth/infra/config/config.go (0.0%)</option>
				
				<option value="file22">github.com/MommusWinner/MicroDurak/internal/services/auth/utils/jwt.go (0.0%)</option>
				
				<option value="file23">github.com/MommusWinner/MicroDurak/internal/services/auth/utils/passwords.go (0.0%)</option>
				
				<option value="file24">github.com/MommusWinner/MicroDurak/internal/services/game-manager/cmd/main.go (0.0%)</option>
				
				<option value="file25">github.com/MommusWinner/MicroDurak/internal/services/game-manager/connection/rabbitmq.go (0.0%)</option>
				
				<option value="file26">github.com/MommusWinner/MicroDurak/internal/services/game-manager/core/ctx.go (0.0%)</option>
				
				<option value="file27">github.com/MommusWinner/MicroDurak/internal/services/game-manager/core/di.go (0.0%)</option>
				
				<option value="file28">github.com/MommusWinner/MicroDurak/internal/services/game-manager/delivery/http/handlers.go (0.0%)</option>
				
				<option value="file29">github.com/MommusWinner/MicroDurak/internal/services/game-manager/delivery/http/metrics.go (0.0%)</option>
				
				<option value="file30">github.com/MommusWinner/MicroDurak/internal/services/game-manager/delivery/http/router.go (0.0%)</option>
				
				<option value="file31">github.com/MommusWinner/MicroDurak/internal/services/game-manager/delivery/http/websocket.go (0.0%)</option>
				
				<option value="file32">github.com/MommusWinner/MicroDurak/internal/services/game-manager/domain/cases/handle_message.go (97.1%)</option>
				
				<option value="file33">github.com/MommusWinner/MicroDurak/internal/services/game-manager/infra/config/config.go (0.0%)</option>
				
				<option value="file34">github.com/MommusWinner/MicroDurak/internal/services/game/cmd/main.go (0.0%)</option>
				
				<option value="file35">github.com/MommusWinner/MicroDurak/internal/services/game/config/config.go (0.0%)</option>
				
				<option value="file36">github.com/MommusWinner/MicroDurak/internal/services/game/controller/controller.go (0.0%)</option>
				
				<option value="file37">github.com/MommusWinner/MicroDurak/internal/services/game/core/checkers.go (75.0%)</option>
				
				<option value="file38">github.com/MommusWinner/MicroDurak/internal/services/game/core/command_handlers.go (86.7%)</option>
				
				<option value="file39">github.com/MommusWinner/MicroDurak/internal/services/game/core/core.go (57.8%)</option>
				
				<option value="file40">github.com/MommusWinner/MicroDurak/internal/services/game/core/events.go (85.0%)</option>
				
				<option value="file41">github.com/MommusWinner/MicroDurak/internal/services/game/core/messages.go (100.0%)</option>
				
				<option value="file42">github.com/MommusWinner/MicroDurak/internal/services/game/grpc/methods.go (0.0%)</option>
				
				<option value="file43">github.com/MommusWinner/MicroDurak/internal/services/matchmaker/cmd/main.go (0.0%)</option>
				
				<option value="file44">github.com/MommusWinner/MicroDurak/internal/services/matchmaker/config/config.go (0.0%)</option>
				
				<option value="file45">github.com/MommusWinner/MicroDurak/internal/services/matchmaker/delivery/http/api.go (0.0%)</option>
				
				<option value="file46">github.com/MommusWinner/MicroDurak/internal/services/matchmaker/delivery/http/docs/docs.go (0.0%)</option>
				
				<option value="file47">github.com/MommusWinner/MicroDurak/internal/services/matchmaker/delivery/http/handlers.go (0.0%)</option>
				
				<option value="file48">github.com/MommusWinner/MicroDurak/internal/services/matchmaker/matchmaker.go (63.5%)</option>
				
				<option value="file49">github.com/MommusWinner/MicroDurak/internal/services/matchmaker/redis/client.go (0.0%)</option>
				
				<option value="file50">github.com/MommusWinner/MicroDurak/internal/services/matchmaker/types/errors.go (0.0%)</option>
				
				<option value="file51">github.com/MommusWinner/MicroDurak/internal/services/matchmaker/types/matches.go (0.0%)</option>
				
				<option value="file52">github.com/MommusWinner/MicroDurak/internal/services/players/cmd/docs/docs.go (0.0%)</option>
				
				<option value="file53">github.com/MommusWinner/MicroDurak/internal/services/players/cmd/main.go (0.0%)</option>
				
				<option value="file54">github.com/MommusWinner/MicroDurak/internal/services/players/connection/connection.go (0.0%)</option>
				
				<option value="file55">github.com/MommusWinner/MicroDurak/internal/services/players/connection/match.go (0.0%)</option>
				
				<option value="file56">github.com/MommusWinner/MicroDurak/internal/services/players/connection/player.go (0.0%)</option>
				
				<option value="file57">github.com/MommusWinner/MicroDurak/internal/services/players/core/ctx.go (0.0%)</option>
				
				<option value="file58">github.com/MommusWinner/MicroDurak/internal/services/players/core/di.go (0.0%)</option>
				
				<option value="file59">github.com/MommusWinner/MicroDurak/internal/services/players/core/grpc_server.go (0.0%)</option>
				
				<option value="file60">github.com/MommusWinner/MicroDurak/internal/services/players/core/http_server.go (0.0%)</option>
				
				<option value="file61">github.com/MommusWinner/MicroDurak/internal/services/players/delivery/grpc/handlers.go (0.0%)</option>
				
				<option value="file62">github.com/MommusWinner/MicroDurak/internal/services/players/delivery/http/docs/docs.go (0.0%)</option>
				
				<option value="file63">github.com/MommusWinner/MicroDurak/internal/services/players/delivery/http/handlers.go (0.0%)</option>
				
				<option value="file64">github.com/MommusWinner/MicroDurak/internal/services/players/delivery/http/router.go (0.0%)</option>
				
				<option value="file65">github.com/MommusWinner/MicroDurak/internal/services/players/domain/cases/match.go (0.0%)</option>
				
				<option value="file66">github.com/MommusWinner/MicroDurak/internal/services/players/domain/cases/player.go (0.0%)</option>
				
				<option value="file67">github.com/MommusWinner/MicroDurak/internal/services/players/infra/config/config.go (0.0%)</option>
				
				<option value="file68">github.com/MommusWinner/MicroDurak/internal/services/players/rating/calculate.go (100.0%)</option>
				
				<option value="file69">github.com/MommusWinner/MicroDurak/lib/amqppool/pool.go (0.0%)</option>
				
				<option value="file70">github.com/MommusWinner/MicroDurak/lib/jwt/check.go (0.0%)</option>
				
				<option value="file71">github.com/MommusWinner/MicroDurak/lib/jwt/middleware.go (0.0%)</option>
				
				<option value="file72">github.com/MommusWinner/MicroDurak/lib/smtp/smtp.go (0.0%)</option>
				
				<option value="file73">github.com/MommusWinner/MicroDurak/lib/validate/validate.go (0.0%)</option>
				
				<option value="file74">github.com/MommusWinner/MicroDurak/tests/integration/client.go (71.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.6
//         protoc        v5.29.3
// source: game/v1/games.proto

package game

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type CreateGameRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        UserIds       []string               `protobuf:"bytes,1,rep,name=user_ids,json=userIds,proto3" json:"user_ids,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CreateGameRequest) Reset() <span class="cov0" title="0">{
        *x = CreateGameRequest{}
        mi := &amp;file_game_v1_games_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreateGameRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateGameRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateGameRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_game_v1_games_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateGameRequest.ProtoReflect.Descriptor instead.
func (*CreateGameRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_game_v1_games_proto_rawDescGZIP(), []int{0}
}</span>

func (x *CreateGameRequest) GetUserIds() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserIds
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CreateGameResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        GameId        string                 `protobuf:"bytes,1,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CreateGameResponse) Reset() <span class="cov0" title="0">{
        *x = CreateGameResponse{}
        mi := &amp;file_game_v1_games_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreateGameResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateGameResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateGameResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_game_v1_games_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateGameResponse.ProtoReflect.Descriptor instead.
func (*CreateGameResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_game_v1_games_proto_rawDescGZIP(), []int{1}
}</span>

func (x *CreateGameResponse) GetGameId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.GameId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_game_v1_games_proto protoreflect.FileDescriptor

const file_game_v1_games_proto_rawDesc = "" +
        "\n" +
        "\x13game/v1/games.proto\".\n" +
        "\x11CreateGameRequest\x12\x19\n" +
        "\buser_ids\x18\x01 \x03(\tR\auserIds\"-\n" +
        "\x12CreateGameResponse\x12\x17\n" +
        "\agame_id\x18\x01 \x01(\tR\x06gameId2?\n" +
        "\x04Game\x127\n" +
        "\n" +
        "CreateGame\x12\x12.CreateGameRequest\x1a\x13.CreateGameResponse\"\x00B\tZ\a./;gameb\x06proto3"

var (
        file_game_v1_games_proto_rawDescOnce sync.Once
        file_game_v1_games_proto_rawDescData []byte
)

func file_game_v1_games_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_game_v1_games_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_game_v1_games_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_game_v1_games_proto_rawDesc), len(file_game_v1_games_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_game_v1_games_proto_rawDescData</span>
}

var file_game_v1_games_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_game_v1_games_proto_goTypes = []any{
        (*CreateGameRequest)(nil),  // 0: CreateGameRequest
        (*CreateGameResponse)(nil), // 1: CreateGameResponse
}
var file_game_v1_games_proto_depIdxs = []int32{
        0, // 0: Game.CreateGame:input_type -&gt; CreateGameRequest
        1, // 1: Game.CreateGame:output_type -&gt; CreateGameResponse
        1, // [1:2] is the sub-list for method output_type
        0, // [0:1] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_game_v1_games_proto_init() }</span>
func file_game_v1_games_proto_init() <span class="cov0" title="0">{
        if File_game_v1_games_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_game_v1_games_proto_rawDesc), len(file_game_v1_games_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   2,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_game_v1_games_proto_goTypes,
                DependencyIndexes: file_game_v1_games_proto_depIdxs,
                MessageInfos:      file_game_v1_games_proto_msgTypes,
        }.Build()
        File_game_v1_games_proto = out.File
        file_game_v1_games_proto_goTypes = nil
        file_game_v1_games_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: game/v1/games.proto

package game

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        Game_CreateGame_FullMethodName = "/Game/CreateGame"
)

// GameClient is the client API for Game service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GameClient interface {
        CreateGame(ctx context.Context, in *CreateGameRequest, opts ...grpc.CallOption) (*CreateGameResponse, error)
}

type gameClient struct {
        cc grpc.ClientConnInterface
}

func NewGameClient(cc grpc.ClientConnInterface) GameClient <span class="cov0" title="0">{
        return &amp;gameClient{cc}
}</span>

func (c *gameClient) CreateGame(ctx context.Context, in *CreateGameRequest, opts ...grpc.CallOption) (*CreateGameResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(CreateGameResponse)
        err := c.cc.Invoke(ctx, Game_CreateGame_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// GameServer is the server API for Game service.
// All implementations must embed UnimplementedGameServer
// for forward compatibility.
type GameServer interface {
        CreateGame(context.Context, *CreateGameRequest) (*CreateGameResponse, error)
        mustEmbedUnimplementedGameServer()
}

// UnimplementedGameServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedGameServer struct{}

func (UnimplementedGameServer) CreateGame(context.Context, *CreateGameRequest) (*CreateGameResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateGame not implemented")
}</span>
func (UnimplementedGameServer) mustEmbedUnimplementedGameServer() {<span class="cov0" title="0">}</span>
func (UnimplementedGameServer) testEmbeddedByValue()              {<span class="cov0" title="0">}</span>

// UnsafeGameServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GameServer will
// result in compilation errors.
type UnsafeGameServer interface {
        mustEmbedUnimplementedGameServer()
}

func RegisterGameServer(s grpc.ServiceRegistrar, srv GameServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedGameServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;Game_ServiceDesc, srv)</span>
}

func _Game_CreateGame_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CreateGameRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(GameServer).CreateGame(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Game_CreateGame_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(GameServer).CreateGame(ctx, req.(*CreateGameRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// Game_ServiceDesc is the grpc.ServiceDesc for Game service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Game_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "Game",
        HandlerType: (*GameServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "CreateGame",
                        Handler:    _Game_CreateGame_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "game/v1/games.proto",
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.6
//         protoc        v5.29.3
// source: players/v1/players.proto

package players

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type GameResult int32

const (
        GameResult_WIN         GameResult = 0
        GameResult_DRAW        GameResult = 1
        GameResult_INTERRUPTED GameResult = 2
)

// Enum value maps for GameResult.
var (
        GameResult_name = map[int32]string{
                0: "WIN",
                1: "DRAW",
                2: "INTERRUPTED",
        }
        GameResult_value = map[string]int32{
                "WIN":         0,
                "DRAW":        1,
                "INTERRUPTED": 2,
        }
)

func (x GameResult) Enum() *GameResult <span class="cov0" title="0">{
        p := new(GameResult)
        *p = x
        return p
}</span>

func (x GameResult) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (GameResult) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_players_v1_players_proto_enumTypes[0].Descriptor()
}</span>

func (GameResult) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_players_v1_players_proto_enumTypes[0]
}</span>

func (x GameResult) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use GameResult.Descriptor instead.
func (GameResult) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_players_v1_players_proto_rawDescGZIP(), []int{0}
}</span>

type Player struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        Name          string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
        Age           int32                  `protobuf:"varint,3,opt,name=age,proto3" json:"age,omitempty"`
        Rating        int32                  `protobuf:"varint,4,opt,name=rating,proto3" json:"rating,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Player) Reset() <span class="cov0" title="0">{
        *x = Player{}
        mi := &amp;file_players_v1_players_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Player) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Player) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Player) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_players_v1_players_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Player.ProtoReflect.Descriptor instead.
func (*Player) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_players_v1_players_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Player) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Player) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Player) GetAge() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Age
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Player) GetRating() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Rating
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type PlayerPlacement struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        MatchResultId string                 `protobuf:"bytes,1,opt,name=match_result_id,json=matchResultId,proto3" json:"match_result_id,omitempty"`
        PlayerId      string                 `protobuf:"bytes,2,opt,name=player_id,json=playerId,proto3" json:"player_id,omitempty"`
        PlayerPlace   int32                  `protobuf:"varint,3,opt,name=player_place,json=playerPlace,proto3" json:"player_place,omitempty"`
        RankChange    int32                  `protobuf:"varint,4,opt,name=rank_change,json=rankChange,proto3" json:"rank_change,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *PlayerPlacement) Reset() <span class="cov0" title="0">{
        *x = PlayerPlacement{}
        mi := &amp;file_players_v1_players_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *PlayerPlacement) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PlayerPlacement) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PlayerPlacement) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_players_v1_players_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PlayerPlacement.ProtoReflect.Descriptor instead.
func (*PlayerPlacement) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_players_v1_players_proto_rawDescGZIP(), []int{1}
}</span>

func (x *PlayerPlacement) GetMatchResultId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MatchResultId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *PlayerPlacement) GetPlayerId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PlayerId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *PlayerPlacement) GetPlayerPlace() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PlayerPlace
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PlayerPlacement) GetRankChange() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RankChange
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetPlayerRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetPlayerRequest) Reset() <span class="cov0" title="0">{
        *x = GetPlayerRequest{}
        mi := &amp;file_players_v1_players_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetPlayerRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetPlayerRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetPlayerRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_players_v1_players_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetPlayerRequest.ProtoReflect.Descriptor instead.
func (*GetPlayerRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_players_v1_players_proto_rawDescGZIP(), []int{2}
}</span>

func (x *GetPlayerRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CreatePlayerRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        Age           int32                  `protobuf:"varint,2,opt,name=age,proto3" json:"age,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CreatePlayerRequest) Reset() <span class="cov0" title="0">{
        *x = CreatePlayerRequest{}
        mi := &amp;file_players_v1_players_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreatePlayerRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreatePlayerRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreatePlayerRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_players_v1_players_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreatePlayerRequest.ProtoReflect.Descriptor instead.
func (*CreatePlayerRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_players_v1_players_proto_rawDescGZIP(), []int{3}
}</span>

func (x *CreatePlayerRequest) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreatePlayerRequest) GetAge() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Age
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type CreatePlayerReply struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CreatePlayerReply) Reset() <span class="cov0" title="0">{
        *x = CreatePlayerReply{}
        mi := &amp;file_players_v1_players_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreatePlayerReply) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreatePlayerReply) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreatePlayerReply) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_players_v1_players_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreatePlayerReply.ProtoReflect.Descriptor instead.
func (*CreatePlayerReply) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_players_v1_players_proto_rawDescGZIP(), []int{4}
}</span>

func (x *CreatePlayerReply) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CreateMatchResultRequest struct {
        state            protoimpl.MessageState    `protogen:"open.v1"`
        GameResult       GameResult                `protobuf:"varint,1,opt,name=game_result,json=gameResult,proto3,enum=GameResult" json:"game_result,omitempty"`
        PlayerPlacements []*PlayerPlacementRequest `protobuf:"bytes,2,rep,name=player_placements,json=playerPlacements,proto3" json:"player_placements,omitempty"`
        unknownFields    protoimpl.UnknownFields
        sizeCache        protoimpl.SizeCache
}

func (x *CreateMatchResultRequest) Reset() <span class="cov0" title="0">{
        *x = CreateMatchResultRequest{}
        mi := &amp;file_players_v1_players_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreateMatchResultRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateMatchResultRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateMatchResultRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_players_v1_players_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateMatchResultRequest.ProtoReflect.Descriptor instead.
func (*CreateMatchResultRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_players_v1_players_proto_rawDescGZIP(), []int{5}
}</span>

func (x *CreateMatchResultRequest) GetGameResult() GameResult <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.GameResult
        }</span>
        <span class="cov0" title="0">return GameResult_WIN</span>
}

func (x *CreateMatchResultRequest) GetPlayerPlacements() []*PlayerPlacementRequest <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PlayerPlacements
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CreateMatchResultResponse struct {
        state         protoimpl.MessageState     `protogen:"open.v1"`
        MatchResultId string                     `protobuf:"bytes,1,opt,name=match_result_id,json=matchResultId,proto3" json:"match_result_id,omitempty"`
        PlayerRatings []*PlayerPlacementResponse `protobuf:"bytes,2,rep,name=player_ratings,json=playerRatings,proto3" json:"player_ratings,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CreateMatchResultResponse) Reset() <span class="cov0" title="0">{
        *x = CreateMatchResultResponse{}
        mi := &amp;file_players_v1_players_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreateMatchResultResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateMatchResultResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateMatchResultResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_players_v1_players_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateMatchResultResponse.ProtoReflect.Descriptor instead.
func (*CreateMatchResultResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_players_v1_players_proto_rawDescGZIP(), []int{6}
}</span>

func (x *CreateMatchResultResponse) GetMatchResultId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MatchResultId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateMatchResultResponse) GetPlayerRatings() []*PlayerPlacementResponse <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PlayerRatings
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type PlayerPlacementRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        PlayerId      string                 `protobuf:"bytes,1,opt,name=player_id,json=playerId,proto3" json:"player_id,omitempty"`
        PlayerPlace   int32                  `protobuf:"varint,2,opt,name=player_place,json=playerPlace,proto3" json:"player_place,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *PlayerPlacementRequest) Reset() <span class="cov0" title="0">{
        *x = PlayerPlacementRequest{}
        mi := &amp;file_players_v1_players_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *PlayerPlacementRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PlayerPlacementRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PlayerPlacementRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_players_v1_players_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PlayerPlacementRequest.ProtoReflect.Descriptor instead.
func (*PlayerPlacementRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_players_v1_players_proto_rawDescGZIP(), []int{7}
}</span>

func (x *PlayerPlacementRequest) GetPlayerId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PlayerId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *PlayerPlacementRequest) GetPlayerPlace() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PlayerPlace
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type PlayerPlacementResponse struct {
        state              protoimpl.MessageState `protogen:"open.v1"`
        PlayerId           string                 `protobuf:"bytes,1,opt,name=player_id,json=playerId,proto3" json:"player_id,omitempty"`
        PlayerRating       int32                  `protobuf:"varint,2,opt,name=player_rating,json=playerRating,proto3" json:"player_rating,omitempty"`
        PlayerRatingChange int32                  `protobuf:"varint,3,opt,name=player_rating_change,json=playerRatingChange,proto3" json:"player_rating_change,omitempty"`
        unknownFields      protoimpl.UnknownFields
        sizeCache          protoimpl.SizeCache
}

func (x *PlayerPlacementResponse) Reset() <span class="cov0" title="0">{
        *x = PlayerPlacementResponse{}
        mi := &amp;file_players_v1_players_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *PlayerPlacementResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PlayerPlacementResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PlayerPlacementResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_players_v1_players_proto_msgTypes[8]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PlayerPlacementResponse.ProtoReflect.Descriptor instead.
func (*PlayerPlacementResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_players_v1_players_proto_rawDescGZIP(), []int{8}
}</span>

func (x *PlayerPlacementResponse) GetPlayerId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PlayerId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *PlayerPlacementResponse) GetPlayerRating() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PlayerRating
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PlayerPlacementResponse) GetPlayerRatingChange() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PlayerRatingChange
        }</span>
        <span class="cov0" title="0">return 0</span>
}

var File_players_v1_players_proto protoreflect.FileDescriptor

const file_players_v1_players_proto_rawDesc = "" +
        "\n" +
        "\x18players/v1/players.proto\"V\n" +
        "\x06Player\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
        "\x04name\x18\x02 \x01(\tR\x04name\x12\x10\n" +
        "\x03age\x18\x03 \x01(\x05R\x03age\x12\x16\n" +
        "\x06rating\x18\x04 \x01(\x05R\x06rating\"\x9a\x01\n" +
        "\x0fPlayerPlacement\x12&amp;\n" +
        "\x0fmatch_result_id\x18\x01 \x01(\tR\rmatchResultId\x12\x1b\n" +
        "\tplayer_id\x18\x02 \x01(\tR\bplayerId\x12!\n" +
        "\fplayer_place\x18\x03 \x01(\x05R\vplayerPlace\x12\x1f\n" +
        "\vrank_change\x18\x04 \x01(\x05R\n" +
        "rankChange\"\"\n" +
        "\x10GetPlayerRequest\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\";\n" +
        "\x13CreatePlayerRequest\x12\x12\n" +
        "\x04name\x18\x01 \x01(\tR\x04name\x12\x10\n" +
        "\x03age\x18\x02 \x01(\x05R\x03age\"#\n" +
        "\x11CreatePlayerReply\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\"\x8e\x01\n" +
        "\x18CreateMatchResultRequest\x12,\n" +
        "\vgame_result\x18\x01 \x01(\x0e2\v.GameResultR\n" +
        "gameResult\x12D\n" +
        "\x11player_placements\x18\x02 \x03(\v2\x17.PlayerPlacementRequestR\x10playerPlacements\"\x84\x01\n" +
        "\x19CreateMatchResultResponse\x12&amp;\n" +
        "\x0fmatch_result_id\x18\x01 \x01(\tR\rmatchResultId\x12?\n" +
        "\x0eplayer_ratings\x18\x02 \x03(\v2\x18.PlayerPlacementResponseR\rplayerRatings\"X\n" +
        "\x16PlayerPlacementRequest\x12\x1b\n" +
        "\tplayer_id\x18\x01 \x01(\tR\bplayerId\x12!\n" +
        "\fplayer_place\x18\x02 \x01(\x05R\vplayerPlace\"\x8d\x01\n" +
        "\x17PlayerPlacementResponse\x12\x1b\n" +
        "\tplayer_id\x18\x01 \x01(\tR\bplayerId\x12#\n" +
        "\rplayer_rating\x18\x02 \x01(\x05R\fplayerRating\x120\n" +
        "\x14player_rating_change\x18\x03 \x01(\x05R\x12playerRatingChange*0\n" +
        "\n" +
        "GameResult\x12\a\n" +
        "\x03WIN\x10\x00\x12\b\n" +
        "\x04DRAW\x10\x01\x12\x0f\n" +
        "\vINTERRUPTED\x10\x022\xbe\x01\n" +
        "\aPlayers\x12:\n" +
        "\fCreatePlayer\x12\x14.CreatePlayerRequest\x1a\x12.CreatePlayerReply\"\x00\x12)\n" +
        "\tGetPlayer\x12\x11.GetPlayerRequest\x1a\a.Player\"\x00\x12L\n" +
        "\x11CreateMatchResult\x12\x19.CreateMatchResultRequest\x1a\x1a.CreateMatchResultResponse\"\x00B\fZ\n" +
        "./;playersb\x06proto3"

var (
        file_players_v1_players_proto_rawDescOnce sync.Once
        file_players_v1_players_proto_rawDescData []byte
)

func file_players_v1_players_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_players_v1_players_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_players_v1_players_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_players_v1_players_proto_rawDesc), len(file_players_v1_players_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_players_v1_players_proto_rawDescData</span>
}

var file_players_v1_players_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_players_v1_players_proto_msgTypes = make([]protoimpl.MessageInfo, 9)
var file_players_v1_players_proto_goTypes = []any{
        (GameResult)(0),                   // 0: GameResult
        (*Player)(nil),                    // 1: Player
        (*PlayerPlacement)(nil),           // 2: PlayerPlacement
        (*GetPlayerRequest)(nil),          // 3: GetPlayerRequest
        (*CreatePlayerRequest)(nil),       // 4: CreatePlayerRequest
        (*CreatePlayerReply)(nil),         // 5: CreatePlayerReply
        (*CreateMatchResultRequest)(nil),  // 6: CreateMatchResultRequest
        (*CreateMatchResultResponse)(nil), // 7: CreateMatchResultResponse
        (*PlayerPlacementRequest)(nil),    // 8: PlayerPlacementRequest
        (*PlayerPlacementResponse)(nil),   // 9: PlayerPlacementResponse
}
var file_players_v1_players_proto_depIdxs = []int32{
        0, // 0: CreateMatchResultRequest.game_result:type_name -&gt; GameResult
        8, // 1: CreateMatchResultRequest.player_placements:type_name -&gt; PlayerPlacementRequest
        9, // 2: CreateMatchResultResponse.player_ratings:type_name -&gt; PlayerPlacementResponse
        4, // 3: Players.CreatePlayer:input_type -&gt; CreatePlayerRequest
        3, // 4: Players.GetPlayer:input_type -&gt; GetPlayerRequest
        6, // 5: Players.CreateMatchResult:input_type -&gt; CreateMatchResultRequest
        5, // 6: Players.CreatePlayer:output_type -&gt; CreatePlayerReply
        1, // 7: Players.GetPlayer:output_type -&gt; Player
        7, // 8: Players.CreateMatchResult:output_type -&gt; CreateMatchResultResponse
        6, // [6:9] is the sub-list for method output_type
        3, // [3:6] is the sub-list for method input_type
        3, // [3:3] is the sub-list for extension type_name
        3, // [3:3] is the sub-list for extension extendee
        0, // [0:3] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_players_v1_players_proto_init() }</span>
func file_players_v1_players_proto_init() <span class="cov0" title="0">{
        if File_players_v1_players_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_players_v1_players_proto_rawDesc), len(file_players_v1_players_proto_rawDesc)),
                        NumEnums:      1,
                        NumMessages:   9,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_players_v1_players_proto_goTypes,
                DependencyIndexes: file_players_v1_players_proto_depIdxs,
                EnumInfos:         file_players_v1_players_proto_enumTypes,
                MessageInfos:      file_players_v1_players_proto_msgTypes,
        }.Build()
        File_players_v1_players_proto = out.File
        file_players_v1_players_proto_goTypes = nil
        file_players_v1_players_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: players/v1/players.proto

package players

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        Players_CreatePlayer_FullMethodName      = "/Players/CreatePlayer"
        Players_GetPlayer_FullMethodName         = "/Players/GetPlayer"
        Players_CreateMatchResult_FullMethodName = "/Players/CreateMatchResult"
)

// PlayersClient is the client API for Players service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PlayersClient interface {
        CreatePlayer(ctx context.Context, in *CreatePlayerRequest, opts ...grpc.CallOption) (*CreatePlayerReply, error)
        GetPlayer(ctx context.Context, in *GetPlayerRequest, opts ...grpc.CallOption) (*Player, error)
        CreateMatchResult(ctx context.Context, in *CreateMatchResultRequest, opts ...grpc.CallOption) (*CreateMatchResultResponse, error)
}

type playersClient struct {
        cc grpc.ClientConnInterface
}

func NewPlayersClient(cc grpc.ClientConnInterface) PlayersClient <span class="cov0" title="0">{
        return &amp;playersClient{cc}
}</span>

func (c *playersClient) CreatePlayer(ctx context.Context, in *CreatePlayerRequest, opts ...grpc.CallOption) (*CreatePlayerReply, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(CreatePlayerReply)
        err := c.cc.Invoke(ctx, Players_CreatePlayer_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *playersClient) GetPlayer(ctx context.Context, in *GetPlayerRequest, opts ...grpc.CallOption) (*Player, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(Player)
        err := c.cc.Invoke(ctx, Players_GetPlayer_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *playersClient) CreateMatchResult(ctx context.Context, in *CreateMatchResultRequest, opts ...grpc.CallOption) (*CreateMatchResultResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(CreateMatchResultResponse)
        err := c.cc.Invoke(ctx, Players_CreateMatchResult_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// PlayersServer is the server API for Players service.
// All implementations must embed UnimplementedPlayersServer
// for forward compatibility.
type PlayersServer interface {
        CreatePlayer(context.Context, *CreatePlayerRequest) (*CreatePlayerReply, error)
        GetPlayer(context.Context, *GetPlayerRequest) (*Player, error)
        CreateMatchResult(context.Context, *CreateMatchResultRequest) (*CreateMatchResultResponse, error)
        mustEmbedUnimplementedPlayersServer()
}

// UnimplementedPlayersServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPlayersServer struct{}

func (UnimplementedPlayersServer) CreatePlayer(context.Context, *CreatePlayerRequest) (*CreatePlayerReply, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreatePlayer not implemented")
}</span>
func (UnimplementedPlayersServer) GetPlayer(context.Context, *GetPlayerRequest) (*Player, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetPlayer not implemented")
}</span>
func (UnimplementedPlayersServer) CreateMatchResult(context.Context, *CreateMatchResultRequest) (*CreateMatchResultResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateMatchResult not implemented")
}</span>
func (UnimplementedPlayersServer) mustEmbedUnimplementedPlayersServer() {<span class="cov0" title="0">}</span>
func (UnimplementedPlayersServer) testEmbeddedByValue()                 {<span class="cov0" title="0">}</span>

// UnsafePlayersServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PlayersServer will
// result in compilation errors.
type UnsafePlayersServer interface {
        mustEmbedUnimplementedPlayersServer()
}

func RegisterPlayersServer(s grpc.ServiceRegistrar, srv PlayersServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedPlayersServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;Players_ServiceDesc, srv)</span>
}

func _Players_CreatePlayer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CreatePlayerRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(PlayersServer).CreatePlayer(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Players_CreatePlayer_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(PlayersServer).CreatePlayer(ctx, req.(*CreatePlayerRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Players_GetPlayer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetPlayerRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(PlayersServer).GetPlayer(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Players_GetPlayer_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(PlayersServer).GetPlayer(ctx, req.(*GetPlayerRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Players_CreateMatchResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CreateMatchResultRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(PlayersServer).CreateMatchResult(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Players_CreateMatchResult_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(PlayersServer).CreateMatchResult(ctx, req.(*CreateMatchResultRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// Players_ServiceDesc is the grpc.ServiceDesc for Players service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Players_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "Players",
        HandlerType: (*PlayersServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "CreatePlayer",
                        Handler:    _Players_CreatePlayer_Handler,
                },
                {
                        MethodName: "GetPlayer",
                        Handler:    _Players_GetPlayer_Handler,
                },
                {
                        MethodName: "CreateMatchResult",
                        Handler:    _Players_CreateMatchResult_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "players/v1/players.proto",
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: auth.sql

package database

import (
        "context"

        "github.com/google/uuid"
)

const createAuth = `-- name: CreateAuth :one
insert into player_auth (player_id, email, password)
values ($1, $2, $3)
returning id
`

type CreateAuthParams struct {
        PlayerID uuid.UUID
        Email    string
        Password string
}

func (q *Queries) CreateAuth(ctx context.Context, arg CreateAuthParams) (uuid.UUID, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createAuth, arg.PlayerID, arg.Email, arg.Password)
        var id uuid.UUID
        err := row.Scan(&amp;id)
        return id, err
}</span>

const getAuthByEmail = `-- name: GetAuthByEmail :one
select id, player_id, email, password from player_auth
 where email = $1
 limit 1
`

func (q *Queries) GetAuthByEmail(ctx context.Context, email string) (PlayerAuth, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getAuthByEmail, email)
        var i PlayerAuth
        err := row.Scan(
                &amp;i.ID,
                &amp;i.PlayerID,
                &amp;i.Email,
                &amp;i.Password,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package database

import (
        "context"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
)

type DBTX interface {
        Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
        Query(context.Context, string, ...interface{}) (pgx.Rows, error)
        QueryRow(context.Context, string, ...interface{}) pgx.Row
}

func New(db DBTX) *Queries <span class="cov0" title="0">{
        return &amp;Queries{db: db}
}</span>

type Queries struct {
        db DBTX
}

func (q *Queries) WithTx(tx pgx.Tx) *Queries <span class="cov0" title="0">{
        return &amp;Queries{
                db: tx,
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: match.sql

package database

import (
        "context"

        "github.com/google/uuid"
)

const addPlayerPlacement = `-- name: AddPlayerPlacement :one
insert into player_placement (match_result_id, player_id, player_place, rating_change)
values ($1, $2, $3, $4)
returning match_result_id, player_id, player_place, rating_change
`

type AddPlayerPlacementParams struct {
        MatchResultID uuid.UUID
        PlayerID      uuid.UUID
        PlayerPlace   int16
        RatingChange  int32
}

func (q *Queries) AddPlayerPlacement(ctx context.Context, arg AddPlayerPlacementParams) (PlayerPlacement, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, addPlayerPlacement,
                arg.MatchResultID,
                arg.PlayerID,
                arg.PlayerPlace,
                arg.RatingChange,
        )
        var i PlayerPlacement
        err := row.Scan(
                &amp;i.MatchResultID,
                &amp;i.PlayerID,
                &amp;i.PlayerPlace,
                &amp;i.RatingChange,
        )
        return i, err
}</span>

const createMatchResult = `-- name: CreateMatchResult :one
insert into match_result (player_count, game_result)
values ($1, $2)
returning id, player_count, game_result
`

type CreateMatchResultParams struct {
        PlayerCount int16
        GameResult  GameResult
}

func (q *Queries) CreateMatchResult(ctx context.Context, arg CreateMatchResultParams) (MatchResult, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createMatchResult, arg.PlayerCount, arg.GameResult)
        var i MatchResult
        err := row.Scan(&amp;i.ID, &amp;i.PlayerCount, &amp;i.GameResult)
        return i, err
}</span>

const getAllMatchResults = `-- name: GetAllMatchResults :many
SELECT mr.id, mr.player_count, mr.game_result
FROM match_result mr
ORDER BY mr.id
`

func (q *Queries) GetAllMatchResults(ctx context.Context) ([]MatchResult, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getAllMatchResults)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []MatchResult
        for rows.Next() </span><span class="cov0" title="0">{
                var i MatchResult
                if err := rows.Scan(&amp;i.ID, &amp;i.PlayerCount, &amp;i.GameResult); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getMatchResultById = `-- name: GetMatchResultById :one
SELECT mr.id, mr.player_count, mr.game_result
FROM match_result mr
WHERE mr.id = $1
`

func (q *Queries) GetMatchResultById(ctx context.Context, id uuid.UUID) (MatchResult, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getMatchResultById, id)
        var i MatchResult
        err := row.Scan(&amp;i.ID, &amp;i.PlayerCount, &amp;i.GameResult)
        return i, err
}</span>

const getPlayerPlacementsByMatchId = `-- name: GetPlayerPlacementsByMatchId :many
SELECT pp.player_id, pp.player_place, pp.rating_change, p.name, p.rating
FROM player_placement pp
JOIN player p ON pp.player_id = p.id
WHERE pp.match_result_id = $1
ORDER BY pp.player_place
`

type GetPlayerPlacementsByMatchIdRow struct {
        PlayerID     uuid.UUID
        PlayerPlace  int16
        RatingChange int32
        Name         string
        Rating       int32
}

func (q *Queries) GetPlayerPlacementsByMatchId(ctx context.Context, matchResultID uuid.UUID) ([]GetPlayerPlacementsByMatchIdRow, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getPlayerPlacementsByMatchId, matchResultID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []GetPlayerPlacementsByMatchIdRow
        for rows.Next() </span><span class="cov0" title="0">{
                var i GetPlayerPlacementsByMatchIdRow
                if err := rows.Scan(
                        &amp;i.PlayerID,
                        &amp;i.PlayerPlace,
                        &amp;i.RatingChange,
                        &amp;i.Name,
                        &amp;i.Rating,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package database

import (
        "database/sql/driver"
        "fmt"

        "github.com/google/uuid"
)

type GameResult string

const (
        GameResultWin        GameResult = "win"
        GameResultDraw       GameResult = "draw"
        GameResultInterruped GameResult = "interruped"
)

func (e *GameResult) Scan(src interface{}) error <span class="cov0" title="0">{
        switch s := src.(type) </span>{
        case []byte:<span class="cov0" title="0">
                *e = GameResult(s)</span>
        case string:<span class="cov0" title="0">
                *e = GameResult(s)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported scan type for GameResult: %T", src)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

type NullGameResult struct {
        GameResult GameResult
        Valid      bool // Valid is true if GameResult is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullGameResult) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                ns.GameResult, ns.Valid = "", false
                return nil
        }</span>
        <span class="cov0" title="0">ns.Valid = true
        return ns.GameResult.Scan(value)</span>
}

// Value implements the driver Valuer interface.
func (ns NullGameResult) Value() (driver.Value, error) <span class="cov0" title="0">{
        if !ns.Valid </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return string(ns.GameResult), nil</span>
}

type MatchResult struct {
        ID          uuid.UUID
        PlayerCount int16
        GameResult  GameResult
}

type Player struct {
        ID     uuid.UUID
        Name   string
        Age    int16
        Rating int32
}

type PlayerAuth struct {
        ID       uuid.UUID
        PlayerID uuid.UUID
        Email    string
        Password string
}

type PlayerPlacement struct {
        MatchResultID uuid.UUID
        PlayerID      uuid.UUID
        PlayerPlace   int16
        RatingChange  int32
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: player.sql

package database

import (
        "context"

        "github.com/google/uuid"
)

const createPlayer = `-- name: CreatePlayer :one
insert into player (name, age, rating)
values ($1, $2, 0)
returning id
`

type CreatePlayerParams struct {
        Name string
        Age  int16
}

func (q *Queries) CreatePlayer(ctx context.Context, arg CreatePlayerParams) (uuid.UUID, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createPlayer, arg.Name, arg.Age)
        var id uuid.UUID
        err := row.Scan(&amp;id)
        return id, err
}</span>

const getAllPlayers = `-- name: GetAllPlayers :many
select id, name, age, rating from player
`

func (q *Queries) GetAllPlayers(ctx context.Context) ([]Player, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getAllPlayers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Player
        for rows.Next() </span><span class="cov0" title="0">{
                var i Player
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Name,
                        &amp;i.Age,
                        &amp;i.Rating,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getPlayerById = `-- name: GetPlayerById :one
select id, name, age, rating from player where id = $1
`

func (q *Queries) GetPlayerById(ctx context.Context, id uuid.UUID) (Player, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getPlayerById, id)
        var i Player
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Name,
                &amp;i.Age,
                &amp;i.Rating,
        )
        return i, err
}</span>

const updatePlayerRating = `-- name: UpdatePlayerRating :one
update player
   set rating = $2
 where id = $1
returning rating
`

type UpdatePlayerRatingParams struct {
        ID     uuid.UUID
        Rating int32
}

func (q *Queries) UpdatePlayerRating(ctx context.Context, arg UpdatePlayerRatingParams) (int32, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, updatePlayerRating, arg.ID, arg.Rating)
        var rating int32
        err := row.Scan(&amp;rating)
        return rating, err
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package main

import (
        "github.com/MommusWinner/MicroDurak/internal/services/auth/core"
        "github.com/MommusWinner/MicroDurak/internal/services/auth/delivery/http"
        "github.com/MommusWinner/MicroDurak/lib/validate"
        "github.com/go-playground/validator"
        "github.com/swaggo/echo-swagger"

        "github.com/labstack/echo/v4"

        _ "github.com/MommusWinner/MicroDurak/internal/services/auth/delivery/http/docs" //  swagger 
)

// @title Auth Service API
// @version 1.0
// @description API for authentication and user registration
// @host localhost:8080
// @basePath /api/v1/auth
func main() <span class="cov0" title="0">{
        e := echo.New()
        e.Validator = validate.NewHttpValidator(validator.New())

        di := core.NewDi()

        e.GET("/swagger/*", echoSwagger.WrapHandler)

        http.AddRoutes(e, di.AuthHandler)

        err := e.Start(":" + di.Ctx.Config().GetPort())
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package connection

import (
        "context"
        "database/sql"
        "errors"

        "github.com/MommusWinner/MicroDurak/internal/database"
        "github.com/MommusWinner/MicroDurak/internal/services/auth/domain/models"
        "github.com/google/uuid"
)

type authRepo struct {
        queries *database.Queries
}

func NewAuthRepository(queries *database.Queries) *authRepo <span class="cov0" title="0">{
        return &amp;authRepo{queries: queries}
}</span>

func (r *authRepo) Add(auth *models.AuthUser) error <span class="cov0" title="0">{
        _, err := r.queries.CreateAuth(context.TODO(), database.CreateAuthParams{PlayerID: auth.PlayerId, Email: auth.Email, Password: auth.Password})
        return err
}</span>

func (r *authRepo) GetByEmail(email string) (*models.AuthUser, error) <span class="cov0" title="0">{
        auth, err := r.queries.GetAuthByEmail(context.TODO(), email)

        if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                return nil, nil
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">domainAuth := databaseAuthToDomain(auth)
        return &amp;domainAuth, nil</span>
}

func (r *authRepo) Delete(id uuid.UUID) error <span class="cov0" title="0">{
        panic("Not implemented")</span>
}

func databaseAuthToDomain(dbPlayer database.PlayerAuth) models.AuthUser <span class="cov0" title="0">{
        return models.AuthUser{
                Id:       dbPlayer.ID,
                PlayerId: dbPlayer.PlayerID,
                Email:    dbPlayer.Email,
                Password: dbPlayer.Password,
        }
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package connection

import (
        "context"
        "fmt"

        "github.com/MommusWinner/MicroDurak/internal/database"
        "github.com/MommusWinner/MicroDurak/internal/services/auth/domain"
        "github.com/MommusWinner/MicroDurak/internal/services/auth/domain/infra"
        "github.com/MommusWinner/MicroDurak/internal/services/auth/domain/repositories"
        "github.com/jackc/pgx/v5"
)

type connection struct {
        conn    *pgx.Conn
        queries *database.Queries

        authRepository repositories.AuthRepository
}

func makeConnection(conn *pgx.Conn) *connection <span class="cov0" title="0">{
        queries := database.New(conn)

        return &amp;connection{
                queries:        queries,
                authRepository: NewAuthRepository(queries),
        }
}</span>

func Make(cfg infra.Config) domain.Connection <span class="cov0" title="0">{
        conn, err := pgx.Connect(context.TODO(), cfg.GetDatabaseURL())

        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("unable to open database due [%s]", err))</span>
        }

        <span class="cov0" title="0">return makeConnection(conn)</span>
}

func Close(conn domain.Connection) <span class="cov0" title="0">{
        c := conn.(*connection)
        c.conn.Close(context.TODO())
}</span>

func (c *connection) AuthRepository() repositories.AuthRepository <span class="cov0" title="0">{
        return c.authRepository
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package core

import (
        "log/slog"
        "os"

        "github.com/MommusWinner/MicroDurak/internal/services/auth/connection"
        "github.com/MommusWinner/MicroDurak/internal/services/auth/domain"
        "github.com/MommusWinner/MicroDurak/internal/services/auth/domain/infra"
        "github.com/MommusWinner/MicroDurak/internal/services/auth/infra/config"
)

type Ctx struct {
        con    domain.Connection
        cfg    infra.Config
        logger *slog.Logger
}

func (c *Ctx) Config() infra.Config <span class="cov0" title="0">{
        return c.cfg
}</span>

func (c *Ctx) Logger() *slog.Logger <span class="cov0" title="0">{
        return c.logger
}</span>

func (c *Ctx) Connection() domain.Connection <span class="cov0" title="0">{
        return c.con
}</span>
func (c *Ctx) Make() domain.Context <span class="cov0" title="0">{
        return &amp;Ctx{
                con:    c.con,
                logger: c.logger,
                cfg:    c.cfg,
        }
}</span>

func InitCtx() *Ctx <span class="cov0" title="0">{
        cfg := config.Make()
        logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))

        db := connection.Make(cfg)

        return &amp;Ctx{
                cfg:    cfg,
                logger: logger,
                con:    db,
        }
}</span>

func DisposeCtx(ctx *Ctx) <span class="cov0" title="0">{
        connection.Close(ctx.con)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package core

import (
        "fmt"

        "github.com/MommusWinner/MicroDurak/internal/services/auth/delivery/http"
        "github.com/MommusWinner/MicroDurak/internal/services/auth/domain"
        "github.com/MommusWinner/MicroDurak/internal/services/auth/domain/cases"
)

type Di struct {
        Ctx         domain.Context
        AuthHandler *http.AuthHandler
}

func NewDi() *Di <span class="cov0" title="0">{
        ctx := InitCtx()
        playersClient := MakePlayersClient(ctx.Config())
        smtp := MakeSMTP(ctx.Config())

        ctx.Logger().Info(fmt.Sprint(smtp))

        var (
                authUseCase = cases.NewAuthUseCase(ctx, playersClient, smtp)
                authHandler = http.NewAuthHandler(authUseCase)
        )

        return &amp;Di{
                Ctx:         ctx,
                AuthHandler: authHandler,
        }
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package core

import (
        "context"
        "fmt"
        "log/slog"
        "sync"
        "time"

        "github.com/MommusWinner/MicroDurak/internal/contracts/players/v1"
        "github.com/MommusWinner/MicroDurak/internal/services/auth/domain/infra"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
)

var (
        client     players.PlayersClient
        clientOnce sync.Once
)

func makeSecureConnection(cfg infra.Config) (*grpc.ClientConn, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        conn, err := grpc.DialContext(ctx, cfg.GetPlayersURL(), grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not connect to grpc client: %v", err)
        }</span>
        <span class="cov0" title="0">return conn, nil</span>
}

func MakePlayersClient(cfg infra.Config) players.PlayersClient <span class="cov0" title="0">{
        clientOnce.Do(func() </span><span class="cov0" title="0">{
                conn, err := makeSecureConnection(cfg)
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("could not create client connection: %v", err))</span>
                }
                <span class="cov0" title="0">client = players.NewPlayersClient(conn)
                slog.Info("Parking client initialized successfully.")</span>
        })
        <span class="cov0" title="0">return client</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package core

import (
        "embed"
        "html/template"

        "github.com/MommusWinner/MicroDurak/internal/services/auth/domain/infra"
        "github.com/MommusWinner/MicroDurak/lib/smtp"
)

//go:embed templates/*.html
var templatesFS embed.FS

type SmtpGreeting struct {
        smtp      smtp.SMTP
        templates *template.Template
}

func MakeSMTP(cfg infra.Config) *SmtpGreeting <span class="cov0" title="0">{
        tmpl, err := template.ParseFS(templatesFS, "templates/*.html")
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">smtp := smtp.SMTP{
                EmailFrom: cfg.GetEmailFrom(),
                User:      cfg.GetSMTPUser(),
                Pass:      cfg.GetSMTPPass(),
                Host:      cfg.GetSMTPHost(),
                Port:      cfg.GetSMTPPort(),
        }

        return &amp;SmtpGreeting{
                smtp:      smtp,
                templates: tmpl,
        }</span>
}

func (s *SmtpGreeting) Send(email string, name string) error <span class="cov0" title="0">{
        return s.smtp.SendEmailWithTemplate(email, &amp;smtp.EmailData{
                Name:    name,
                Subject: "Your account verification code",
        }, s.templates, "greeting.html")
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/login": {
            "post": {
                "description": "Authenticates a user with email and password, returns JWT token",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Login user",
                "parameters": [
                    {
                        "description": "Login credentials",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/delivery_http.LoginRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "400": {
                        "description": "Bad Request"
                    },
                    "403": {
                        "description": "Forbidden"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/register": {
            "post": {
                "description": "Creates a new user account with the provided information",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Register a new user",
                "parameters": [
                    {
                        "description": "Registration data",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/delivery_http.RegisterRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "User successfully registered",
                        "schema": {
                            "$ref": "#/definitions/delivery_http.AuthResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request"
                    },
                    "409": {
                        "description": "Conflict"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        }
    },
    "definitions": {
        "delivery_http.AuthResponse": {
            "type": "object",
            "properties": {
                "player_id": {
                    "type": "string"
                },
                "token": {
                    "type": "string"
                }
            }
        },
        "delivery_http.LoginRequest": {
            "type": "object",
            "required": [
                "email",
                "password"
            ],
            "properties": {
                "email": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                }
            }
        },
        "delivery_http.RegisterRequest": {
            "type": "object",
            "required": [
                "age",
                "email",
                "name",
                "password"
            ],
            "properties": {
                "age": {
                    "type": "integer",
                    "maximum": 130,
                    "minimum": 0
                },
                "email": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "localhost:8080",
        BasePath:         "/api/v1/auth",
        Schemes:          []string{},
        Title:            "Auth Service API",
        Description:      "API for authentication and user registration",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package http

import (
        "errors"
        "net/http"

        "github.com/MommusWinner/MicroDurak/internal/services/auth/domain/cases"
        "github.com/MommusWinner/MicroDurak/internal/services/auth/domain/props"
        "github.com/labstack/echo/v4"
)

type AuthHandler struct {
        useCase *cases.AuthUseCase
}

func NewAuthHandler(useCase *cases.AuthUseCase) *AuthHandler <span class="cov0" title="0">{
        return &amp;AuthHandler{
                useCase: useCase,
        }
}</span>

type AuthResponse struct {
        PlayerID string `json:"player_id"`
        Token    string `json:"token"`
}

type RegisterRequest struct {
        Name     string `json:"name" validate:"required"`
        Age      int16  `json:"age" validate:"required,gte=0,lte=130"`
        Email    string `json:"email" validate:"required,email"`
        Password string `json:"password" validate:"required"`
}

type LoginRequest struct {
        Email    string `json:"email" validate:"required,email"`
        Password string `json:"password" validate:"required"`
}

var internalServerError = echo.NewHTTPError(http.StatusInternalServerError, "Internal Server Error")

// Register creates a new user account
// @Summary Register a new user
// @Description Creates a new user account with the provided information
// @Tags auth
// @Accept json
// @Produce json
// @Param request body RegisterRequest true "Registration data"
// @Success 201 {object} AuthResponse "User successfully registered"
// @Failure 400
// @Failure 409
// @Failure 500
// @Router /register [post]
func (h *AuthHandler) Register(c echo.Context) error <span class="cov0" title="0">{
        r := new(RegisterRequest)
        if err := c.Bind(r); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, err)
        }</span>
        <span class="cov0" title="0">if err := c.Validate(r); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">resp, err := h.useCase.Register(props.RegisterReq{Name: r.Name, Age: int(r.Age), Email: r.Email, Password: r.Password})

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, cases.ErrEmailAlreadyTaken) </span><span class="cov0" title="0">{
                        return c.String(http.StatusConflict, "Email Taken")
                }</span>
                <span class="cov0" title="0">return internalServerError</span>
        }

        <span class="cov0" title="0">return c.JSON(http.StatusCreated, AuthResponse{
                PlayerID: resp.PlayerId.String(),
                Token:    resp.Token,
        })</span>
}

// Login authenticates a user and returns a token
// @Summary Login user
// @Description Authenticates a user with email and password, returns JWT token
// @Tags auth
// @Accept json
// @Produce json
// @Param request body LoginRequest true "Login credentials"
// @Success 200
// @Failure 400
// @Failure 403
// @Failure 500
// @Router /login [post]
func (h *AuthHandler) Login(c echo.Context) error <span class="cov0" title="0">{
        r := new(LoginRequest)
        if err := c.Bind(r); err != nil </span><span class="cov0" title="0">{
                return c.String(http.StatusBadRequest, "bad request")
        }</span>

        <span class="cov0" title="0">resp, err := h.useCase.Login(props.LoginReq{Email: r.Email, Password: r.Password})

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, cases.ErrLoginFailed) </span><span class="cov0" title="0">{
                        return c.String(http.StatusForbidden, "Login failed")
                }</span> else<span class="cov0" title="0"> {
                        return internalServerError
                }</span>
        }

        <span class="cov0" title="0">return c.JSON(http.StatusOK, AuthResponse{
                PlayerID: resp.PlayerId,
                Token:    resp.Token,
        })</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package http

import (
        "github.com/labstack/echo/v4"
        echoSwagger "github.com/swaggo/echo-swagger"
)

func AddRoutes(e *echo.Echo, authHandler *AuthHandler) <span class="cov0" title="0">{
        // Swagger documentation
        e.GET("/swagger/*", echoSwagger.WrapHandler)

        // API routes
        e.POST("/api/v1/auth/login", authHandler.Login)
        e.POST("/api/v1/auth/register", authHandler.Register)
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package cases

import (
        "github.com/MommusWinner/MicroDurak/internal/contracts/players/v1"
        "github.com/MommusWinner/MicroDurak/internal/services/auth/domain"
        "github.com/MommusWinner/MicroDurak/internal/services/auth/domain/props"
        "github.com/MommusWinner/MicroDurak/internal/services/auth/utils"
)

type AuthUseCase struct {
        ctx           domain.Context
        playersClient players.PlayersClient
        smtp          domain.SMTP
}

func NewAuthUseCase(ctx domain.Context, playersClient players.PlayersClient, smtp domain.SMTP) *AuthUseCase <span class="cov0" title="0">{
        return &amp;AuthUseCase{
                ctx:           ctx,
                playersClient: playersClient,
                smtp:          smtp,
        }
}</span>

func (uc *AuthUseCase) Login(args props.LoginReq) (resp props.LoginResp, err error) <span class="cov0" title="0">{
        user, err := uc.ctx.Connection().AuthRepository().GetByEmail(args.Email)

        if err != nil </span><span class="cov0" title="0">{
                uc.ctx.Logger().Error(err.Error())
                err = ErrInternal
                return
        }</span>

        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                err = ErrLoginFailed
                return
        }</span>

        <span class="cov0" title="0">if !utils.CheckPasswordHash(args.Password, user.Password) </span><span class="cov0" title="0">{
                err = ErrLoginFailed
                return
        }</span>

        <span class="cov0" title="0">jwt, err := utils.GenerateToken(uc.ctx.Config().GetJwtPrivate(), user.PlayerId.String())
        if err != nil </span><span class="cov0" title="0">{
                uc.ctx.Logger().Error(err.Error())
                err = ErrInternal
                return
        }</span>

        <span class="cov0" title="0">resp = props.LoginResp{
                PlayerId: user.PlayerId.String(),
                Token:    jwt,
        }
        return</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package cases

import (
        "context"

        "github.com/google/uuid"

        "github.com/MommusWinner/MicroDurak/internal/contracts/players/v1"
        "github.com/MommusWinner/MicroDurak/internal/services/auth/domain/models"
        "github.com/MommusWinner/MicroDurak/internal/services/auth/domain/props"
        "github.com/MommusWinner/MicroDurak/internal/services/auth/utils"
)

func (uc *AuthUseCase) Register(args props.RegisterReq) (resp props.RegisterResp, err error) <span class="cov0" title="0">{
        user, err := uc.ctx.Connection().AuthRepository().GetByEmail(args.Email)
        if err != nil </span><span class="cov0" title="0">{
                uc.ctx.Logger().Error(err.Error())
                err = ErrInternal
                return
        }</span>

        <span class="cov0" title="0">if user != nil </span><span class="cov0" title="0">{
                err = ErrEmailAlreadyTaken
                return
        }</span>

        <span class="cov0" title="0">rep, err := uc.playersClient.CreatePlayer(context.Background(), &amp;players.CreatePlayerRequest{
                Name: args.Name,
                Age:  int32(args.Age),
        })

        if err != nil </span><span class="cov0" title="0">{
                uc.ctx.Logger().Error(err.Error())
                err = ErrInternal
                return
        }</span>

        <span class="cov0" title="0">if uc.smtp == nil </span><span class="cov0" title="0">{
                uc.ctx.Logger().Error("Smtp is nil")
                err = ErrInternal
                return
        }</span> else<span class="cov0" title="0"> {
                err = uc.smtp.Send(args.Email, args.Name)
                uc.ctx.Logger().Info("Send email")
                if err != nil </span><span class="cov0" title="0">{
                        uc.ctx.Logger().Error(err.Error())
                }</span>
        }

        <span class="cov0" title="0">hashedPassword, err := utils.HashPassword(args.Password)
        if err != nil </span><span class="cov0" title="0">{
                uc.ctx.Logger().Error(err.Error())
                err = ErrInternal
                return
        }</span>

        <span class="cov0" title="0">playerId, err := uuid.Parse(rep.Id)
        uc.ctx.Logger().Info(playerId.String())
        err = uc.ctx.Connection().AuthRepository().Add(&amp;models.AuthUser{PlayerId: playerId, Email: args.Email, Password: hashedPassword})

        if err != nil </span><span class="cov0" title="0">{
                uc.ctx.Logger().Error(err.Error())
                err = ErrInternal
                return
        }</span>

        <span class="cov0" title="0">jwt, err := utils.GenerateToken(uc.ctx.Config().GetJwtPrivate(), playerId.String())
        if err != nil </span><span class="cov0" title="0">{
                uc.ctx.Logger().Error(err.Error())
                err = ErrInternal
                return
        }</span>

        <span class="cov0" title="0">resp = props.RegisterResp{
                PlayerId: playerId,
                Token:    jwt,
        }
        return</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package config

import (
        "github.com/alecthomas/kong"
        "log"
)

import ()

type Config struct {
        JWTPrivate  string `help:"Base64 Private key for the jwt"       env:"JWT_PRIVATE" required:"true"`
        PlayersURL  string `help:"URL pointing to the Players Service"  env:"PLAYERS_URL" required:"true"`
        Port        string `help:"Port to listen on"                    env:"PORT" default:"8080"`
        DatabaseURL string `help:"Database connection URL"              env:"DATABASE_URL" required:"true"`
        LogLevel    string `help:"Log level (debug, info, warn, error)" env:"LOG_LEVEL" default:"info"`

        //SMTP
        EmailFrom string `env:"EMAIL_FROM" required:"true"`
        SMTPHost  string `env:"SMTP_HOST"  required:"true"`
        SMTPPass  string `env:"SMTP_PASS"  required:"true"`
        SMTPPort  int    `env:"SMTP_PORT"  required:"true"`
        SMTPUser  string `env:"SMTP_USER"  required:"true"`
}

// func Load() (*Config, error) {
//         cfg := &amp;Config{}
//         parser, err := kong.New(cfg)
//         if err != nil {
//                 return nil, err
//         }
//
//         // Parse command-line flags, environment variables, and config file
//         _, err = parser.Parse(nil)
//         if err != nil {
//                 return nil, err
//         }
//
//         return cfg, nil
// }

func Make() *Config <span class="cov0" title="0">{
        cfg := &amp;Config{}
        parser, err := kong.New(cfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Panic(err)
        }</span>

        // Parse command-line flags, environment variables, and config file
        <span class="cov0" title="0">_, err = parser.Parse(nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Panic(err)
        }</span>
        <span class="cov0" title="0">return cfg</span>
}

func (s *Config) GetJwtPrivate() string <span class="cov0" title="0">{
        return s.JWTPrivate
}</span>

func (s *Config) GetPlayersURL() string <span class="cov0" title="0">{
        return s.PlayersURL
}</span>

func (s *Config) GetPort() string <span class="cov0" title="0">{
        return s.Port
}</span>
func (s *Config) GetDatabaseURL() string <span class="cov0" title="0">{
        return s.DatabaseURL
}</span>

func (s *Config) GetLogLevel() string <span class="cov0" title="0">{
        return s.LogLevel
}</span>

func (s *Config) GetEmailFrom() string <span class="cov0" title="0">{
        return s.EmailFrom
}</span>

func (s *Config) GetSMTPHost() string <span class="cov0" title="0">{
        return s.SMTPHost
}</span>

func (s *Config) GetSMTPPass() string <span class="cov0" title="0">{
        return s.SMTPPass
}</span>

func (s *Config) GetSMTPPort() int <span class="cov0" title="0">{
        return s.SMTPPort
}</span>

func (s *Config) GetSMTPUser() string <span class="cov0" title="0">{
        return s.SMTPUser
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package utils

import (
        "crypto/rsa"
        "encoding/base64"
        "time"

        "github.com/golang-jwt/jwt/v5"
)

func GetPrivateKey(encoded string) (*rsa.PrivateKey, error) <span class="cov0" title="0">{
        pemBytes, err := base64.StdEncoding.DecodeString(encoded)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return jwt.ParseRSAPrivateKeyFromPEM(pemBytes)</span>
}

func GenerateToken(encoded string, userID string) (string, error) <span class="cov0" title="0">{
        privateKey, err := GetPrivateKey(encoded)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">token := jwt.NewWithClaims(jwt.SigningMethodRS256, jwt.RegisteredClaims{
                Subject:   userID,
                ExpiresAt: jwt.NewNumericDate(time.Now().AddDate(1000, 0, 0)),
                Issuer:    "micro-durak",
        })
        return token.SignedString(privateKey)</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package utils

import "golang.org/x/crypto/bcrypt"

func HashPassword(password string) (string, error) <span class="cov0" title="0">{
        bytes, err := bcrypt.GenerateFromPassword([]byte(password), 14)
        return string(bytes), err
}</span>

func CheckPasswordHash(password, hash string) bool <span class="cov0" title="0">{
        err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
        return err == nil
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package main

import (
        "context"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/MommusWinner/MicroDurak/internal/services/game-manager/core"
        "github.com/MommusWinner/MicroDurak/internal/services/game-manager/delivery/http"
        "github.com/labstack/echo/v4"
)

func main() <span class="cov0" title="0">{
        e := echo.New()

        di := core.NewDi()
        defer core.DisposeCtx(di.Ctx.(*core.Ctx))

        http.AddRoutes(e, di.Handler, di.Ctx)

        errChan := make(chan error, 1)
        go func() </span><span class="cov0" title="0">{
                di.Ctx.Logger().Info("Game manager server starting...", "port", di.Ctx.Config().GetPort())
                if err := e.Start(":" + di.Ctx.Config().GetPort()); err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                }</span>
        }()

        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)

        select </span>{
        case err := &lt;-errChan:<span class="cov0" title="0">
                di.Ctx.Logger().Error("Server error", "error", err.Error())
                shutdown(e, di)</span>
        case &lt;-quit:<span class="cov0" title="0">
                di.Ctx.Logger().Info("Shutting down game manager service...")
                shutdown(e, di)
                di.Ctx.Logger().Info("Game manager service stopped gracefully")</span>
        }
}

func shutdown(e *echo.Echo, di *core.Di) <span class="cov0" title="0">{
        shutdownCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        if err := e.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                di.Ctx.Logger().Error("Failed to shutdown Echo server", "error", err.Error())
        }</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package connection

import (
        "context"
        "fmt"
        "log"
        "time"

        "github.com/MommusWinner/MicroDurak/internal/services/game-manager/domain"
        "github.com/MommusWinner/MicroDurak/internal/services/game-manager/domain/infra"
        "github.com/MommusWinner/MicroDurak/lib/amqppool"
        amqp "github.com/rabbitmq/amqp091-go"
)

type messaging struct {
        conn *amqp.Connection
        pool *amqppool.ChannelPool
}

func NewMessaging(conn *amqp.Connection) domain.Messaging <span class="cov0" title="0">{
        return &amp;messaging{
                conn: conn,
                pool: amqppool.NewChannelPool(conn, 20),
        }
}</span>

func (m *messaging) ProcessQueue(gameId string, userId string, processMessage func([]byte)) error <span class="cov0" title="0">{
        queue_name := "game-manager-" + userId + "_" + gameId
        exchange_name := "game-manager-ex"

        channel, err := m.pool.Get()
        defer m.pool.Return(channel)

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Declare err: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">_, err = channel.QueueDeclare(
                queue_name, // name
                false,      // durable
                false,      // delete when unused
                false,      // exclusive
                false,      // no-wait
                nil,        // arguments
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Declare err: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">err = channel.ExchangeDeclare(
                exchange_name, // name
                "direct",      // type
                true,          // durable
                false,         // auto-deleted
                false,         // internal
                false,         // no-wait
                nil,           // arguments
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Exchange err: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">msgs, err := channel.Consume(
                queue_name, // queue
                "",         // consumer
                true,       // auto-ack
                false,      // exclusive
                false,      // no-local
                false,      // no-wait
                nil,        // args
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Consume err: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">for d := range msgs </span><span class="cov0" title="0">{
                processMessage(d.Body)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (m *messaging) SendMessageToGame(message []byte) error <span class="cov0" title="0">{
        channel, err := m.pool.Get()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to get channel from pool: %v", err)
                return err
        }</span>
        <span class="cov0" title="0">defer m.pool.Return(channel)

        queue_name := "game"
        exchange_name := "gameEx"

        _, err = channel.QueueDeclare(
                queue_name, // name
                false,      // durable
                false,      // delete when unused
                false,      // exclusive
                false,      // no-wait
                nil,        // arguments
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Print(err)
                return err
        }</span>

        <span class="cov0" title="0">err = channel.ExchangeDeclare(
                exchange_name, // name
                "direct",      // type
                true,          // durable
                false,         // auto-deleted
                false,         // internal
                false,         // no-wait
                nil,           // arguments
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Print(err)
                return err
        }</span>

        <span class="cov0" title="0">err = channel.QueueBind(
                queue_name,    // queue name
                queue_name,    // routing key
                exchange_name, // exchange
                false,
                nil,
        )

        if err != nil </span><span class="cov0" title="0">{
                log.Print(err)
                return err
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)
        defer cancel()

        err = channel.PublishWithContext(ctx,
                exchange_name, // exchange
                queue_name,    // routing key
                false,         // mandatory
                false,         // immediate
                amqp.Publishing{
                        ContentType: "text/plain",
                        Body:        message,
                })
        if err != nil </span><span class="cov0" title="0">{
                log.Print(err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func Make(cfg infra.Config) (*amqp.Connection, error) <span class="cov0" title="0">{
        conn, err := amqp.Dial(cfg.GetRabbitmqURL())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to connect to rabbitmq due [%s]", err)
        }</span>

        <span class="cov0" title="0">return conn, nil</span>
}

func Close(conn *amqp.Connection) <span class="cov0" title="0">{
        if conn != nil </span><span class="cov0" title="0">{
                conn.Close()
        }</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package core

import (
        "log/slog"
        "os"

        "github.com/MommusWinner/MicroDurak/internal/services/game-manager/connection"
        "github.com/MommusWinner/MicroDurak/internal/services/game-manager/domain"
        "github.com/MommusWinner/MicroDurak/internal/services/game-manager/domain/infra"
        "github.com/MommusWinner/MicroDurak/internal/services/game-manager/infra/config"
        amqp "github.com/rabbitmq/amqp091-go"
)

type Ctx struct {
        cfg       infra.Config
        logger    *slog.Logger
        messaging domain.Messaging
        conn      *amqp.Connection
}

func (c *Ctx) Config() infra.Config <span class="cov0" title="0">{
        return c.cfg
}</span>

func (c *Ctx) Logger() *slog.Logger <span class="cov0" title="0">{
        return c.logger
}</span>

func (c *Ctx) Messaging() domain.Messaging <span class="cov0" title="0">{
        return c.messaging
}</span>

func (c *Ctx) Make() domain.Context <span class="cov0" title="0">{
        return &amp;Ctx{
                cfg:       c.cfg,
                logger:    c.logger,
                messaging: c.messaging,
                conn:      c.conn,
        }
}</span>

func InitCtx() *Ctx <span class="cov0" title="0">{
        cfg := config.Make()
        logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))

        conn, err := connection.Make(cfg)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">messaging := connection.NewMessaging(conn)

        return &amp;Ctx{
                cfg:       cfg,
                logger:    logger,
                messaging: messaging,
                conn:      conn,
        }</span>
}

func DisposeCtx(ctx *Ctx) <span class="cov0" title="0">{
        connection.Close(ctx.conn)
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package core

import (
        "github.com/MommusWinner/MicroDurak/internal/services/game-manager/delivery/http"
        "github.com/MommusWinner/MicroDurak/internal/services/game-manager/domain"
        "github.com/MommusWinner/MicroDurak/internal/services/game-manager/domain/cases"
)

type Di struct {
        Ctx                  domain.Context
        Handler              *http.GameManagerHandler
        HandleMessageUseCase *cases.HandleMessageUseCase
}

func NewDi() *Di <span class="cov0" title="0">{
        ctx := InitCtx()

        var (
                metrics              = http.NewMetricsAdapter()
                handleMessageUseCase = cases.NewHandleMessageUseCase(ctx, metrics)
                handler              = http.NewGameManagerHandler(ctx, handleMessageUseCase)
        )

        return &amp;Di{
                Ctx:                  ctx,
                Handler:              handler,
                HandleMessageUseCase: handleMessageUseCase,
        }
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package http

import (
        "github.com/MommusWinner/MicroDurak/internal/services/game-manager/domain"
        "github.com/MommusWinner/MicroDurak/internal/services/game-manager/domain/cases"
        "github.com/MommusWinner/MicroDurak/internal/services/game-manager/domain/props"
        "github.com/gorilla/websocket"
        "github.com/labstack/echo/v4"
)

var (
        upgrader = websocket.Upgrader{}
)

type GameManagerHandler struct {
        ctx                  domain.Context
        handleMessageUseCase *cases.HandleMessageUseCase
}

func NewGameManagerHandler(ctx domain.Context, handleMessageUseCase *cases.HandleMessageUseCase) *GameManagerHandler <span class="cov0" title="0">{
        return &amp;GameManagerHandler{
                ctx:                  ctx,
                handleMessageUseCase: handleMessageUseCase,
        }
}</span>

func (h *GameManagerHandler) Connect(c echo.Context) error <span class="cov0" title="0">{
        ws, err := upgrader.Upgrade(c.Response(), c.Request(), nil)

        userId, ok := c.Get("playerId").(string)
        if !ok </span><span class="cov0" title="0">{
                if ws != nil </span><span class="cov0" title="0">{
                        ws.Close()
                }</span>
                <span class="cov0" title="0">return echo.NewHTTPError(401, "Unauthorized")</span>
        }

        <span class="cov0" title="0">gameId := c.Param("gameId")
        if gameId == "" </span><span class="cov0" title="0">{
                c.Response().Status = 400
                if ws != nil </span><span class="cov0" title="0">{
                        ws.Close()
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                if ws != nil </span><span class="cov0" title="0">{
                        ws.Close()
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">defer ws.Close()

        wsAdapter := NewWebSocketAdapter(ws)

        err = h.handleMessageUseCase.ConnectWebSocket(props.ConnectWebSocketReq{
                GameId:    gameId,
                UserId:    userId,
                WebSocket: wsAdapter,
        })

        return err</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package http

import (
        "github.com/MommusWinner/MicroDurak/internal/services/game-manager/domain"
        "github.com/MommusWinner/MicroDurak/internal/services/game-manager/metrics"
)

type metricsAdapter struct{}

func NewMetricsAdapter() domain.Metrics <span class="cov0" title="0">{
        return &amp;metricsAdapter{}
}</span>

func (m *metricsAdapter) IncPlayersConnected(podName, namespace string) <span class="cov0" title="0">{
        metrics.PlayersConnected.WithLabelValues(podName, namespace).Inc()
}</span>

func (m *metricsAdapter) DecPlayersConnected(podName, namespace string) <span class="cov0" title="0">{
        metrics.PlayersConnected.WithLabelValues(podName, namespace).Dec()
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package http

import (
        "github.com/MommusWinner/MicroDurak/internal/services/game-manager/domain"
        "github.com/MommusWinner/MicroDurak/lib/jwt"
        "github.com/labstack/echo/v4"
)

func AddRoutes(e *echo.Echo, handler *GameManagerHandler, ctx domain.Context) <span class="cov0" title="0">{
        e.GET("/api/v1/game-manager/:gameId", handler.Connect, jwt.AuthMiddleware(ctx.Config().GetJWTPublic()))
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package http

import (
        "github.com/MommusWinner/MicroDurak/internal/services/game-manager/domain"
        "github.com/gorilla/websocket"
)

type webSocketAdapter struct {
        conn *websocket.Conn
}

func NewWebSocketAdapter(conn *websocket.Conn) domain.WebSocket <span class="cov0" title="0">{
        return &amp;webSocketAdapter{conn: conn}
}</span>

func (w *webSocketAdapter) ReadMessage() (message []byte, err error) <span class="cov0" title="0">{
        _, msg, err := w.conn.ReadMessage()
        return msg, err
}</span>

func (w *webSocketAdapter) WriteMessage(message []byte) error <span class="cov0" title="0">{
        return w.conn.WriteMessage(1, message)
}</span>

func (w *webSocketAdapter) Close() error <span class="cov0" title="0">{
        return w.conn.Close()
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package cases

import (
        "log"
        "time"

        "github.com/MommusWinner/MicroDurak/internal/services/game-manager/domain"
        "github.com/MommusWinner/MicroDurak/internal/services/game-manager/domain/props"
)

type HandleMessageUseCase struct {
        ctx     domain.Context
        metrics domain.Metrics
}

func NewHandleMessageUseCase(ctx domain.Context, metrics domain.Metrics) *HandleMessageUseCase <span class="cov4" title="7">{
        return &amp;HandleMessageUseCase{
                ctx:     ctx,
                metrics: metrics,
        }
}</span>

func (uc *HandleMessageUseCase) HandleMessage(args props.HandleMessageReq) (resp props.HandleMessageResp, err error) <span class="cov3" title="4">{
        err = uc.ctx.Messaging().SendMessageToGame(args.Message)
        if err != nil </span><span class="cov2" title="2">{
                uc.ctx.Logger().Error("Failed to send message to game", "error", err.Error())
                err = ErrInternal
                return
        }</span>

        <span class="cov2" title="2">resp = props.HandleMessageResp{
                Success: true,
        }
        return</span>
}

func (uc *HandleMessageUseCase) ConnectWebSocket(args props.ConnectWebSocketReq) error <span class="cov3" title="5">{
        ws := args.WebSocket

        uc.metrics.IncPlayersConnected(uc.ctx.Config().GetPodName(), uc.ctx.Config().GetNamespace())
        defer uc.metrics.DecPlayersConnected(uc.ctx.Config().GetPodName(), uc.ctx.Config().GetNamespace())

        endRead := make(chan bool)
        defer close(endRead)

        go func() </span><span class="cov3" title="5">{
                for </span><span class="cov3" title="6">{
                        select </span>{
                        case &lt;-endRead:<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov3" title="6">
                                msg, err := ws.ReadMessage()
                                if err != nil </span><span class="cov3" title="4">{
                                        uc.ctx.Logger().Error("Failed to read message", "error", err.Error())
                                        return
                                }</span>
                                <span class="cov2" title="2">log.Printf("ReadMessage: %v", string(msg))

                                _, err = uc.HandleMessage(props.HandleMessageReq{
                                        GameId:  args.GameId,
                                        UserId:  args.UserId,
                                        Message: msg,
                                })
                                if err != nil </span><span class="cov1" title="1">{
                                        uc.ctx.Logger().Error("Failed to handle message", "error", err.Error())
                                        return
                                }</span>
                                <span class="cov1" title="1">log.Printf("%s\n", msg)</span>
                        }
                }
        }()

        <span class="cov3" title="5">for </span><span class="cov10" title="281">{
                err := uc.ctx.Messaging().ProcessQueue(args.GameId, args.UserId, func(message []byte) </span><span class="cov1" title="1">{
                        if err := ws.WriteMessage(message); err != nil </span><span class="cov1" title="1">{
                                uc.ctx.Logger().Error("Failed to write message", "error", err.Error())
                        }</span>
                })
                <span class="cov10" title="281">if err != nil </span><span class="cov9" title="280">{
                        uc.ctx.Logger().Error("Failed to process queue", "error", err.Error())
                }</span>

                <span class="cov10" title="281">time.Sleep(10 * time.Millisecond)</span>
        }
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package config

import (
        "github.com/alecthomas/kong"
        "log"

        "github.com/MommusWinner/MicroDurak/internal/services/game-manager/domain/infra"
)

type config struct {
        JWTPublic   string `help:"Base64 Private key for the jwt"       env:"JWT_PUBLIC"   required:"true"`
        RabbitmqURL string `help:"Rabbitmq connection URL"              env:"RABBITMQ_URL" required:"true"`
        Port        string `help:"Port to listen on"                    env:"PORT"                         default:"7070"`
        PodName     string `help:"K8s pod name" env:"POD_NAME" default:"unknown"`
        Namespace   string `help:"K8s namespace" env:"NAMESPACE" default:"unknown"`
        LogLevel    string `help:"Log level (debug, info, warn, error)" env:"LOG_LEVEL"                    default:"info"`
}

func Make() infra.Config <span class="cov0" title="0">{
        cfg := &amp;config{}
        parser, err := kong.New(cfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Panic(err)
        }</span>

        // Parse command-line flags, environment variables, and config file
        <span class="cov0" title="0">_, err = parser.Parse(nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Panic(err)
        }</span>

        <span class="cov0" title="0">return cfg</span>
}

func (s *config) GetJWTPublic() string <span class="cov0" title="0">{
        return s.JWTPublic
}</span>

func (s *config) GetRabbitmqURL() string <span class="cov0" title="0">{
        return s.RabbitmqURL
}</span>

func (s *config) GetPort() string <span class="cov0" title="0">{
        return s.Port
}</span>

func (s *config) GetPodName() string <span class="cov0" title="0">{
        return s.PodName
}</span>

func (s *config) GetNamespace() string <span class="cov0" title="0">{
        return s.Namespace
}</span>

func (s *config) GetLogLevel() string <span class="cov0" title="0">{
        return s.LogLevel
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package main

import (
        "fmt"
        "log"
        "net"
        "os"
        "os/signal"
        "syscall"

        pb "github.com/MommusWinner/MicroDurak/internal/contracts/game/v1"
        "github.com/MommusWinner/MicroDurak/internal/services/game/config"
        "github.com/MommusWinner/MicroDurak/internal/services/game/controller"
        gameGrpc "github.com/MommusWinner/MicroDurak/internal/services/game/grpc"
        amqp "github.com/rabbitmq/amqp091-go"
        "github.com/redis/go-redis/v9"
        "google.golang.org/grpc"
)

func run(grpcServer *grpc.Server) error <span class="cov0" title="0">{
        conf, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">opt, err := redis.ParseURL(conf.RedisURL)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">client := redis.NewClient(opt)
        channel, err := connectToRabbit(conf)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">errChan := make(chan error, 2)

        gameController := controller.NewGameController(conf, channel, client)
        pb.RegisterGameServer(grpcServer, gameGrpc.NewGameServer(&amp;gameController, conf))

        go func() </span><span class="cov0" title="0">{
                errChan &lt;- startGrpc(grpcServer, conf)
        }</span>()

        <span class="cov0" title="0">go gameController.ProcessQueues()

        quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)

        select </span>{
        case err := &lt;-errChan:<span class="cov0" title="0">
                return err</span>
        case &lt;-quit:<span class="cov0" title="0">
                log.Println("\nShutting down servers...")

                grpcServer.GracefulStop()
                fmt.Println("Servers stopped successfully")
                return nil</span>
        }
}

func startGrpc(grpcServer *grpc.Server, conf *config.Config) error <span class="cov0" title="0">{
        log.Printf("Starting gRPC server on :%s\n", conf.GRPCPort)
        lis, err := net.Listen("tcp", ":"+conf.GRPCPort)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("gRPC listen error: %w", err)
        }</span>

        <span class="cov0" title="0">if err := grpcServer.Serve(lis); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("gRPC server error: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func connectToRabbit(conf *config.Config) (*amqp.Channel, error) <span class="cov0" title="0">{
        conn, err := amqp.Dial(conf.RabbitmqURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">channel, err := conn.Channel()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return channel, err</span>
}

func main() <span class="cov0" title="0">{
        grpcServer := grpc.NewServer()

        if err := run(grpcServer); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package config

import (
        "github.com/alecthomas/kong"
)

type Config struct {
        RedisURL        string `help:"Redis connection URL"                 env:"REDIS_URL"         required:"true"`
        RabbitmqURL     string `help:"Rabbitmq connection URL"              env:"RABBITMQ_URL"      required:"true"`
        GameServicePort string `help:"Port to listen on"                    env:"GAME_SERVICE_PORT"                 default:"7077"`
        GRPCPort        string `help:"Port to listen on"                    env:"GRPC_PORT"         required:"true" default:"9090"`
        LogLevel        string `help:"Log level (debug, info, warn, error)" env:"LOG_LEVEL"                         default:"info"`
}

func Load() (*Config, error) <span class="cov0" title="0">{
        cfg := &amp;Config{}
        parser, err := kong.New(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Parse command-line flags, environment variables, and config file
        <span class="cov0" title="0">_, err = parser.Parse(nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package controller

import (
        "context"
        "encoding/json"
        "log"
        "time"

        "github.com/MommusWinner/MicroDurak/internal/services/game/config"
        "github.com/MommusWinner/MicroDurak/internal/services/game/core"
        amqp "github.com/rabbitmq/amqp091-go"
        "github.com/redis/go-redis/v9"
)

type GameController struct {
        Config  *config.Config
        Channel *amqp.Channel
        Redis   *redis.Client
}

func NewGameController(
        conf *config.Config,
        channel *amqp.Channel,
        redis *redis.Client,
) GameController <span class="cov0" title="0">{
        return GameController{
                Config:  conf,
                Channel: channel,
                Redis:   redis,
        }
}</span>

func (gc GameController) CreateGame(userIds []string) (*core.Game, error) <span class="cov0" title="0">{
        return core.CreateNewGameAndSaveInRedis(gc.Redis, userIds)
}</span>

func (gc GameController) LoadGame(gameId string) (*core.Game, error) <span class="cov0" title="0">{
        return core.LoadGame(gc.Redis, gameId)
}</span>

func (gc GameController) ProcessQueues() <span class="cov0" title="0">{
        gc.processQueue(func(message []byte) </span><span class="cov0" title="0">{
                var command core.Command
                json.Unmarshal(message, &amp;command)
                game, err := core.LoadGame(gc.Redis, command.GameId)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Room with id %s does not exist", command.GameId)
                        return
                }</span>

                <span class="cov0" title="0">messageByUser, err := game.HandleMessage(message)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Error occurred while processing a messag. Room id: %s", command.GameId)
                        return
                }</span>

                <span class="cov0" title="0">for userId, userMessage := range messageByUser </span><span class="cov0" title="0">{

                        log.Printf("Get message by %s", userId)
                        log.Printf("Message:  %s", userMessage)
                        gc.SendMessageToGameManager(game.Id, userId, userMessage)
                }</span>
                <span class="cov0" title="0">core.SaveGame(game, gc.Redis)</span>
        })
}

func (gc GameController) processQueue(processMessage func([]byte)) <span class="cov0" title="0">{
        queue_name := "game"
        exchange_name := "gameEx"

        _, err := gc.Channel.QueueDeclare(
                queue_name, // name
                false,      // durable
                false,      // delete when unused
                false,      // exclusive
                false,      // no-wait
                nil,        // arguments
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Declare err: %v", err)
                panic(err)</span>
        }
        <span class="cov0" title="0">err = gc.Channel.ExchangeDeclare(
                exchange_name, // name
                "direct",      // type
                true,          // durable
                false,         // auto-deleted
                false,         // internal
                false,         // no-wait
                nil,           // arguments
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Exchange err: %v", err)
                panic(err)</span>
        }
        <span class="cov0" title="0">msgs, _ := gc.Channel.Consume(
                queue_name, // queue
                "",         // consumer
                true,       // auto-ack
                false,      // exclusive
                false,      // no-local
                false,      // no-wait
                nil,        // args
        )

        func() </span><span class="cov0" title="0">{
                for d := range msgs </span><span class="cov0" title="0">{
                        processMessage(d.Body)
                }</span>
        }()
}

func (gc GameController) SendMessageToGameManager(
        gameId string,
        userId string,
        message []byte,
) error <span class="cov0" title="0">{
        queue_name := "game-manager-" + userId + "_" + gameId
        exchange_name := "game-manager-ex"

        _, err := gc.Channel.QueueDeclare(
                queue_name, // name
                false,      // durable
                false,      // delete when unused
                false,      // exclusive
                false,      // no-wait
                nil,        // arguments
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Print(err)
                return err
        }</span>

        <span class="cov0" title="0">err = gc.Channel.ExchangeDeclare(
                exchange_name, // name
                "direct",      // type
                true,          // durable
                false,         // auto-deleted
                false,         // internal
                false,         // no-wait
                nil,           // arguments
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Print(err)
                return err
        }</span>

        <span class="cov0" title="0">err = gc.Channel.QueueBind(
                queue_name,    // queue name
                queue_name,    // routing key
                exchange_name, // exchange
                false,
                nil,
        )

        if err != nil </span><span class="cov0" title="0">{
                log.Print(err)
                return err
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)
        defer cancel()

        err = gc.Channel.PublishWithContext(ctx,
                exchange_name, // exChannelange
                queue_name,    // routing key
                false,         // mandatory
                false,         // immediate
                amqp.Publishing{
                        ContentType: "text/plain",
                        Body:        message,
                })
        if err != nil </span><span class="cov0" title="0">{
                log.Print(err)
                return err
        }</span>

        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package core

import (
        "fmt"
        "time"
)

func (g *Game) checkIsAttacker(userId string) string <span class="cov6" title="16">{
        if userId == g.DefendingId </span><span class="cov0" title="0">{
                return ERROR_BAD_REQUEST
        }</span>

        <span class="cov6" title="16">if contains(g.EndAttackUserId, g.AttackingId) </span><span class="cov1" title="1">{
                if contains(g.EndAttackUserId, userId) </span><span class="cov0" title="0">{
                        return ERROR_NOT_YOUR_TURN
                }</span>
                <span class="cov1" title="1">return ERROR_EMPTY</span>
        } else<span class="cov6" title="15"> {
                if userId == g.AttackingId </span><span class="cov6" title="15">{
                        return ERROR_EMPTY
                }</span>
                <span class="cov0" title="0">return ERROR_NOT_YOUR_TURN</span>
        }
}

func (g *Game) checkIsDefender(userId string) string <span class="cov4" title="5">{
        if userId != g.DefendingId </span><span class="cov0" title="0">{
                return ERROR_NOT_YOUR_TURN
        }</span>
        <span class="cov4" title="5">return ERROR_EMPTY</span>
}

func (g *Game) checkUserHasCard(user *User, card Card) string <span class="cov6" title="16">{
        card, err := getCardBySuitAndRank(user.Cards, card.Suit, card.Rank)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(card)
                return ERROR_USER_NO_HAS_CARD
        }</span>
        <span class="cov6" title="16">return ERROR_EMPTY</span>
}

func (g *Game) checkAttackTimer() string <span class="cov6" title="17">{
        if !g.AttackTimerIsRunning </span><span class="cov0" title="0">{
                return ERROR_EMPTY
        }</span>
        <span class="cov6" title="17">now := time.Now()
        if now.Sub(g.AttackTimerStartedAt).Seconds() &gt;= g.Settings.TimeOver </span><span class="cov1" title="1">{
                return ERROR_ATTACK_TIME_OVER
        }</span>
        <span class="cov6" title="16">return ERROR_EMPTY</span>
}

func (g *Game) checkDefendTimer() string <span class="cov4" title="5">{
        if !g.DefendTimerIsRunning </span><span class="cov0" title="0">{
                return ERROR_EMPTY
        }</span>
        <span class="cov4" title="5">now := time.Now()
        if now.Sub(g.DefendTimerStartedAt).Seconds() &gt;= g.Settings.TimeOver </span><span class="cov1" title="1">{
                return ERROR_DEFEND_TIME_OVER
        }</span>
        <span class="cov3" title="4">return ERROR_EMPTY</span>
}

func (g *Game) checkSameRankCard(rank int) string <span class="cov3" title="3">{
        if !tableHasCardRank(g.TableCards, rank) </span><span class="cov1" title="1">{
                return ERROR_NO_SAME_RANK_CARD_IN_TABLE
        }</span>
        <span class="cov2" title="2">return ERROR_EMPTY</span>
}

func (g *Game) checkCardOnTable(suit int, rank int) string <span class="cov3" title="4">{
        targetCardExist := tableHasCard(g.TableCards, suit, rank)

        if !targetCardExist </span><span class="cov0" title="0">{
                return ERROR_NOT_FOUND_CART_ON_TABLE
        }</span>

        <span class="cov3" title="4">return ERROR_EMPTY</span>
}

func (g *Game) checkCardGreater(suit int, rank int, tsuit int, trank int) string <span class="cov3" title="4">{
        greaterThanTarget := CardGreater(suit, rank, tsuit, trank, g.TrumpSuit)
        if !greaterThanTarget </span><span class="cov0" title="0">{
                return ERROR_TARGET_CARD_GREATER_THEN_YOUR
        }</span>

        <span class="cov3" title="4">return ERROR_EMPTY</span>
}

func (g *Game) checkGameStarted() string <span class="cov6" title="23">{
        if !g.IsStarted </span><span class="cov0" title="0">{
                return ERROR_GAME_SHOULD_BE_STARTED
        }</span>

        <span class="cov6" title="23">return ERROR_EMPTY</span>
}

func (g *Game) checkNotFirstTurn() string <span class="cov3" title="4">{
        if len(g.TableCards) == 0 </span><span class="cov0" title="0">{
                return ERROR_CANNOT_END_ATTACK_IN_FIRST_TURN
        }</span>

        <span class="cov3" title="4">return ERROR_EMPTY</span>
}

func (g *Game) checkAllCardsBeatOff() string <span class="cov3" title="4">{
        if !allCardBeatOff(g.TableCards) </span><span class="cov0" title="0">{
                return ERROR_ALL_CARD_SHOULD_BE_BEAT_OFF_BEFORE_END_ATTACK
        }</span>

        <span class="cov3" title="4">return ERROR_EMPTY</span>
}

func (g *Game) checkTableHoldsOnlySixCards() string <span class="cov5" title="12">{
        if len(g.TableCards) &gt;= 6 </span><span class="cov0" title="0">{
                return ERROR_TABLE_HOLDS_ONLY_SIX_CARDS
        }</span>

        <span class="cov5" title="12">return ERROR_EMPTY</span>
}

func (g *Game) checkDefenderHasCards() string <span class="cov5" title="12">{
        defender, _ := g.getUserById(g.DefendingId)
        if len(defender.Cards) &lt;= 0 </span><span class="cov0" title="0">{
                return ERROR_DEFENDER_NO_CARDS
        }</span>

        <span class="cov5" title="12">return ERROR_EMPTY</span>
}

func errorChecker(gameErrors []string) string <span class="cov6" title="23">{
        for _, gameError := range gameErrors </span><span class="cov10" title="117">{
                if gameError != ERROR_EMPTY </span><span class="cov3" title="3">{
                        return gameError
                }</span>
        }

        <span class="cov6" title="20">return ERROR_EMPTY</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package core

import (
        "time"
)

// Attacker end attack
func (g *Game) EndAttackHandler(command Command, user *User) CommandResponse <span class="cov5" title="4">{
        gameErrors := []string{
                g.checkNotFirstTurn(),
                g.checkGameStarted(),
                g.checkIsAttacker(command.UserId),
                g.checkAttackTimer(),
                g.checkAllCardsBeatOff(),
        }

        gameError := errorChecker(gameErrors)

        if gameError != ERROR_EMPTY </span><span class="cov0" title="0">{
                return CommandResponse{
                        Error:   gameError,
                        Command: command,
                        State:   gameToGameStateResponse(g, user),
                }
        }</span>

        <span class="cov5" title="4">g.EndAttackUserId = append(g.EndAttackUserId, command.UserId)

        defendUser, _ := g.getUserById(g.DefendingId)
        attackUser, _ := g.getUserById(g.AttackingId)

        if len(g.EndAttackUserId) == len(g.Users)-1 </span><span class="cov4" title="3">{
                g.EndAttack(true)

                if len(g.Deck) == 0 &amp;&amp; len(defendUser.Cards) == 0 &amp;&amp; len(attackUser.Cards) == 0 </span><span class="cov0" title="0">{
                        g.AddEventToBuffer(NewEndGameEvent(GameResultDraw))
                }</span> else<span class="cov4" title="3"> if len(g.Deck) == 0 &amp;&amp; len(defendUser.Cards) == 0 </span><span class="cov0" title="0">{
                        g.AddEventToBuffer(NewEndGameEvent(GameResultWin))
                }</span> else<span class="cov4" title="3"> if len(g.Deck) == 0 &amp;&amp; len(attackUser.Cards) == 0 </span><span class="cov1" title="1">{
                        g.AddEventToBuffer(NewEndGameEvent(GameResultWin))
                }</span>
        }

        <span class="cov5" title="4">return CommandResponse{
                Error:   ERROR_EMPTY,
                Command: command,
                State:   gameToGameStateResponse(g, user),
        }</span>
}

func (g *Game) AttackHandler(attackCommand AttackCommand, user *User) CommandResponse <span class="cov8" title="12">{
        gameErrors := []string{
                g.checkGameStarted(),
                g.checkIsAttacker(attackCommand.UserId),
                g.checkUserHasCard(user, attackCommand.Card),
                g.checkAttackTimer(),
                g.checkDefenderHasCards(),
                g.checkTableHoldsOnlySixCards(),
        }

        if len(g.TableCards) != 0 </span><span class="cov4" title="3">{
                // It is correct if this is the first card in the table or
                // if there is a card of the same rank in the table
                gameErrors = append(gameErrors, g.checkSameRankCard(attackCommand.Card.Rank))
        }</span>

        <span class="cov8" title="12">gameError := errorChecker(gameErrors)
        if gameError == ERROR_ATTACK_TIME_OVER </span><span class="cov1" title="1">{
                g.EndAttack(true)
        }</span>

        <span class="cov8" title="12">if gameError != ERROR_EMPTY </span><span class="cov3" title="2">{
                return CommandResponse{
                        Error:   gameError,
                        Command: attackCommand,
                        State:   gameToGameStateResponse(g, user),
                }
        }</span>

        <span class="cov7" title="10">tableCard := TableCard{}
        tableCard.Suit = attackCommand.Card.Suit
        tableCard.Rank = attackCommand.Card.Rank

        g.TableCards = append(g.TableCards, tableCard)
        err := g.removeUserCard(user.Id, tableCard.Suit, tableCard.Rank)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResponse{
                        Error:   ERROR_SERVER,
                        Command: attackCommand,
                        State:   gameToGameStateResponse(g, user),
                }
        }</span>
        <span class="cov7" title="10">g.EndAttackUserId = make([]string, 0)
        g.StartDefendTimer()
        g.AddEventToBuffer(
                NewAttackEvent(attackCommand.Card, attackCommand.UserId),
        )

        return CommandResponse{
                Error:   ERROR_EMPTY,
                Command: attackCommand,
                State:   gameToGameStateResponse(g, user),
        }</span>
}

func (g *Game) DefendHandler(defendCommand DefendCommand, user *User) CommandResponse <span class="cov5" title="4">{
        gameError := errorChecker(
                []string{
                        g.checkGameStarted(),
                        g.checkDefendTimer(),
                        g.checkIsDefender(defendCommand.UserId),
                        g.checkUserHasCard(user, defendCommand.UserCard),
                        g.checkCardOnTable(defendCommand.TargetCard.Suit, defendCommand.TargetCard.Rank),
                        g.checkCardGreater(
                                defendCommand.UserCard.Suit,
                                defendCommand.UserCard.Rank,
                                defendCommand.TargetCard.Suit,
                                defendCommand.TargetCard.Rank,
                        ),
                },
        )

        if gameError == ERROR_DEFEND_TIME_OVER </span><span class="cov1" title="1">{ // TODO: remove this stuff
                g.AddEventToBuffer(NewEndAttackEvent())
        }</span>

        <span class="cov5" title="4">if gameError != ERROR_EMPTY </span><span class="cov1" title="1">{
                return CommandResponse{
                        Error:   gameError,
                        Command: defendCommand,
                        State:   gameToGameStateResponse(g, user),
                }
        }</span>

        <span class="cov4" title="3">g.removeUserCard(user.Id, defendCommand.UserCard.Suit, defendCommand.UserCard.Rank)
        g.beatOffCard(
                defendCommand.UserCard.Suit,
                defendCommand.UserCard.Rank,
                defendCommand.TargetCard,
        )

        g.AddEventToBuffer(
                NewDefendEvent(
                        defendCommand.UserCard,
                        defendCommand.TargetCard,
                        user.Id,
                        gameToGameStateResponse(g, user),
                ),
        )

        if allCardBeatOff(g.TableCards) &amp;&amp; len(g.TableCards) &lt; 6 </span><span class="cov4" title="3">{
                g.StartAttackTimer()
        }</span>

        <span class="cov4" title="3">return CommandResponse{
                Error:   ERROR_EMPTY,
                Command: defendCommand,
                State:   gameToGameStateResponse(g, user),
        }</span>
}

func (g *Game) TakeAllCardHandler(command Command, user *User) CommandResponse <span class="cov1" title="1">{
        gameError := errorChecker(
                []string{
                        g.checkGameStarted(),
                        g.checkIsDefender(command.UserId),
                },
        )

        if gameError != ERROR_EMPTY </span><span class="cov0" title="0">{
                return CommandResponse{
                        Error:   gameError,
                        Command: command,
                        State:   gameToGameStateResponse(g, user),
                }
        }</span>

        <span class="cov1" title="1">tableCards := tableCardsToCards(g.TableCards)
        user.Cards = append(user.Cards, tableCards...)
        g.TableCards = []TableCard{}

        g.AddEventToBuffer(NewTakeAllCardsEvent(user.Id))

        g.EndAttack(false)

        if len(g.Users) &gt; 2 </span><span class="cov1" title="1">{
                newAttacker, _ := g.nextUser(g.DefendingId)
                newDefender, _ := g.nextUser(newAttacker.Id)

                g.AttackingId = newAttacker.Id
                g.DefendingId = newDefender.Id
        }</span>

        <span class="cov1" title="1">return CommandResponse{
                Error:   ERROR_EMPTY,
                Command: command,
                State:   gameToGameStateResponse(g, user),
        }</span>
}

func (g *Game) ReadyHandler(command Command, user *User) CommandResponse <span class="cov10" title="22">{
        if contains(g.ReadyUsers, user.Id) </span><span class="cov0" title="0">{
                return CommandResponse{
                        Error:   ERROR_USER_ALREADY_READY,
                        Command: command,
                        State:   gameToGameStateResponse(g, user),
                }
        }</span>

        <span class="cov10" title="22">g.ReadyUsers = append(g.ReadyUsers, user.Id)

        if len(g.ReadyUsers) &gt;= len(g.Users) </span><span class="cov7" title="10">{
                g.IsStarted = true
                g.StartAttackTimer()
                g.AddEventToBuffer(NewReadyEvent(user.Id))
                g.AddEventToBuffer(NewStartGameEvent(gameToGameStateResponse(g, user)))
        }</span> else<span class="cov8" title="12"> {
                g.AddEventToBuffer(NewReadyEvent(user.Id))
        }</span>

        <span class="cov10" title="22">return CommandResponse{
                Error:   ERROR_EMPTY,
                Command: command,
                State:   gameToGameStateResponse(g, user),
        }</span>
}

func (g *Game) CheckAttackTimerHandler(command Command, user *User) CommandResponse <span class="cov1" title="1">{
        gameError := errorChecker(
                []string{
                        g.checkGameStarted(),
                },
        )

        if gameError != ERROR_EMPTY </span><span class="cov0" title="0">{
                return CommandResponse{
                        Error:   gameError,
                        Command: command,
                        State:   gameToGameStateResponse(g, user),
                }
        }</span>

        <span class="cov1" title="1">if g.checkAttackTimer() == ERROR_ATTACK_TIME_OVER </span><span class="cov0" title="0">{
                g.EndAttack(true)
        }</span>

        <span class="cov1" title="1">if g.AttackTimerIsRunning </span><span class="cov1" title="1">{
                timeEndAt := g.AttackTimerStartedAt.Add(time.Duration(g.Settings.TimeOver) * time.Second)
                g.AddEventToBuffer(
                        NewAttackTimerStateEvent(false, &amp;timeEndAt),
                )
        }</span> else<span class="cov0" title="0"> {
                g.AddEventToBuffer(NewAttackTimerStateEvent(true, nil))
        }</span>

        <span class="cov1" title="1">return CommandResponse{
                Error:   ERROR_EMPTY,
                Command: command,
                State:   gameToGameStateResponse(g, user),
        }</span>
}

func (g *Game) CheckDefendTimerHandler(command Command, user *User) CommandResponse <span class="cov1" title="1">{
        gameError := errorChecker(
                []string{
                        g.checkGameStarted(),
                },
        )

        if gameError != ERROR_EMPTY </span><span class="cov0" title="0">{
                return CommandResponse{
                        Error:   gameError,
                        Command: command,
                        State:   gameToGameStateResponse(g, user),
                }
        }</span>

        <span class="cov1" title="1">if g.checkDefendTimer() == ERROR_DEFEND_TIME_OVER </span><span class="cov0" title="0">{
                g.EndAttack(true)
        }</span>

        <span class="cov1" title="1">if g.DefendTimerIsRunning </span><span class="cov1" title="1">{
                timeEndAt := g.DefendTimerStartedAt.Add(time.Duration(g.Settings.TimeOver) * time.Second)
                g.AddEventToBuffer(
                        NewDefendTimerStateEvent(false, &amp;timeEndAt),
                )
        }</span> else<span class="cov0" title="0"> {
                g.AddEventToBuffer(NewDefendTimerStateEvent(true, nil))
        }</span>

        <span class="cov1" title="1">return CommandResponse{
                Error:   ERROR_EMPTY,
                Command: command,
                State:   gameToGameStateResponse(g, user),
        }</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package core

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "log"
        "math/rand/v2"
        "time"

        "github.com/google/uuid"
        "github.com/redis/go-redis/v9"
)

var (
        DefaultGameSettings = GameSettings{
                TimeOver: 3000000000,
        }
)

type GameSettings struct {
        TimeOver float64
}

type Card struct {
        Suit int `json:"suit"`
        Rank int `json:"rank"`
}

type UserStatus int

const (
        Wait UserStatus = iota
        Attack
        Deffend
)

type User struct {
        Id         string     `json:"id"`
        Place      int        `json:"place"`
        Status     UserStatus `json:"status"`
        Name       string     `json:"name"`
        Cards      []Card     `json:"cards"`
        TakenCards []Card     `json:"taken_cards"`
}

type UserResponse struct {
        Id               string     `json:"id"`
        Status           UserStatus `json:"status"`
        Name             string     `json:"name"`
        CardLength       int        `json:"card_length"`
        TakenCardsLength int        `json:"taken_cards_length"`
}

type TableCard struct {
        Card
        BeatOff *Card `json:"beat_off"`
}

type Game struct {
        Id              string        `json:"id"`
        Settings        *GameSettings `json:"settings"`
        Users           []*User       `json:"users"`
        AttackingId     string        `json:"attacking_id"`
        DefendingId     string        `json:"defending_id"`
        Deck            []Card        `json:"deck"`
        TrumpSuit       int           `json:"trump_suit"` // TODO: remove
        TableCards      []TableCard   `json:"table_cards"`
        EndAttackUserId []string      `json:"end_attack_user_id"`
        ReadyUsers      []string      `json:"ready_users"`
        IsStarted       bool          `json:"is_Started"`

        AttackTimerIsRunning bool      `json:"attack_timer_is_running"`
        AttackTimerStartedAt time.Time `json:"attack_timer_started_at"`
        AttackTimerEndedAt   time.Time `json:"attack_timer_ended_at"`

        DefendTimerIsRunning bool      `json:"defend_timer_is_running"`
        DefendTimerStartedAt time.Time `json:"defend_timer_started_at"`
        DefendTimerEndedAt   time.Time `json:"defend_timer_ended_at"`

        GameEventBuffer []GameEventContainer `json:"game_event_buffer"`
}

func CreateNewGameAndSaveInRedis(redis *redis.Client, userIds []string) (*Game, error) <span class="cov0" title="0">{ // TODO: move to handler layer
        game, err := CreateNewGame(userIds)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">result, _ := json.Marshal(game)
        log.Print(string(result))

        ctx := context.Background()
        // TODO: Change expiration time
        status := redis.Set(ctx, "game:"+game.Id, string(result), 0)
        if status.Err() != nil </span><span class="cov0" title="0">{
                log.Fatal("Couldn't create game room: " + game.Id)
        }</span> else<span class="cov0" title="0"> {
                log.Print("Create game room: " + game.Id)
        }</span>

        <span class="cov0" title="0">return game, nil</span>
}

func SaveGame(game *Game, redis *redis.Client) <span class="cov0" title="0">{ // TODO: move to handler layer
        result, _ := json.Marshal(game)
        log.Print(string(result))

        ctx := context.Background()
        // TODO: Change expiration time
        status := redis.Set(ctx, "game:"+game.Id, string(result), 0)
        if status.Err() != nil </span><span class="cov0" title="0">{
                log.Fatal("Couldn't save game room: " + game.Id)
        }</span> else<span class="cov0" title="0"> {
                log.Print("Save game room: " + game.Id)
        }</span>
}

func CreateNewGame(userIds []string) (*Game, error) <span class="cov4" title="10">{
        id := uuid.New()
        deck := generateDeck()
        trum_suit := deck[0].Suit

        shackeCards(deck)
        users := make([]*User, len(userIds))
        for i := range users </span><span class="cov5" title="22">{
                userCards := deck[len(deck)-6:]
                deck = deck[:len(deck)-6]

                users[i] = &amp;User{
                        Id:     userIds[i],
                        Place:  i,
                        Status: Wait,
                        Name:   "",
                        Cards:  userCards,
                }
        }</span>

        <span class="cov4" title="10">game := Game{
                Id:         id.String(),
                Settings:   &amp;DefaultGameSettings,
                Users:      users,
                Deck:       deck,
                TrumpSuit:  trum_suit,
                TableCards: []TableCard{},
        }

        // select first attacking and defending user
        attacking_i := rand.IntN(len(users))
        game.AttackingId = users[attacking_i].Id
        defending, err := game.nextUser(game.AttackingId)
        if err != nil </span>{<span class="cov0" title="0">
                // TODO: log
        }</span>
        <span class="cov4" title="10">game.DefendingId = defending.Id

        return &amp;game, nil</span>
}

func LoadGame(redis *redis.Client, gameId string) (*Game, error) <span class="cov0" title="0">{
        ctx := context.Background()
        value, err := redis.Get(ctx, "game:"+gameId).Result()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var game Game

        log.Print(value)
        err = json.Unmarshal([]byte(value), &amp;game)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">log.Printf("Success load game (%s)\n%s", gameId, value)

        return &amp;game, err</span>
}

func (g *Game) HandleMessage(msg []byte) (map[string][]byte, error) <span class="cov0" title="0">{
        var command Command
        err := json.Unmarshal(msg, &amp;command)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">user, err := g.getUserById(command.UserId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var response CommandResponse

        switch command.Action </span>{
        case ACTION_READY:<span class="cov0" title="0">
                response = g.ReadyHandler(command, user)</span>
        case ACTION_ATTACK:<span class="cov0" title="0">
                var attackCommand AttackCommand
                json.Unmarshal(msg, &amp;attackCommand)
                response = g.AttackHandler(attackCommand, user)</span>
        case ACTION_DEFEND:<span class="cov0" title="0">
                var defendCommand DefendCommand
                json.Unmarshal(msg, &amp;defendCommand)
                response = g.DefendHandler(defendCommand, user)</span>
        case ACTION_END_ATTACK:<span class="cov0" title="0">
                response = g.EndAttackHandler(command, user)</span>
        case ACTION_TAKE_ALL_CARDS:<span class="cov0" title="0">
                response = g.TakeAllCardHandler(command, user)</span>
        case ACTION_CHECK_ATTACK_TIMER:<span class="cov0" title="0">
                response = g.CheckAttackTimerHandler(command, user)</span>
        case ACTION_CHECK_DEFEND_TIMER:<span class="cov0" title="0">
                response = g.CheckDefendTimerHandler(command, user)</span>
        default:<span class="cov0" title="0">
                response = CommandResponse{
                        Error:   ERROR_UNREGISTERED_ACTION,
                        Command: command,
                        State:   gameToGameStateResponse(g, user),
                }</span>
        }

        <span class="cov0" title="0">return g.GeneratePack(response, user), nil</span>
}

func (g *Game) StartAttackTimer() <span class="cov4" title="13">{
        g.AttackTimerIsRunning = true
        g.AttackTimerStartedAt = time.Now()
}</span>

func (g *Game) StartDefendTimer() <span class="cov4" title="10">{
        g.DefendTimerIsRunning = true
        g.DefendTimerStartedAt = time.Now()
}</span>

func (g *Game) StopAttackTimer() <span class="cov3" title="5">{
        g.AttackTimerIsRunning = false
}</span>

func (g *Game) StopDefendTimer() <span class="cov3" title="5">{
        g.DefendTimerIsRunning = false
}</span>

func (g *Game) removeUserCard(userId string, suit int, rank int) error <span class="cov4" title="13">{
        user, err := g.getUserById(userId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="13">for i := range user.Cards </span><span class="cov4" title="13">{
                if user.Cards[i].Suit == suit &amp;&amp; user.Cards[i].Rank == rank </span><span class="cov4" title="13">{
                        user.Cards = append(user.Cards[i+1:], user.Cards[:i]...)
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return errors.New("User not found")</span>
}

func (g *Game) beatOffCard(suit int, rank int, targetCard Card) bool <span class="cov2" title="3">{
        for i := range g.TableCards </span><span class="cov2" title="3">{
                if g.TableCards[i].Suit == targetCard.Suit &amp;&amp; g.TableCards[i].Rank == targetCard.Rank </span><span class="cov2" title="3">{
                        if CardGreater(suit, rank, targetCard.Suit, targetCard.Rank, g.TrumpSuit) </span><span class="cov2" title="3">{
                                g.TableCards[i].BeatOff = &amp;Card{Suit: suit, Rank: rank}
                                return true
                        }</span> else<span class="cov0" title="0"> {
                                return false
                        }</span>
                }
        }

        <span class="cov0" title="0">return false</span>
}

func (g *Game) GeneratePack(response CommandResponse, user *User) map[string][]byte <span class="cov0" title="0">{
        responseByUser := make(map[string][]byte, 0)

        messagePackByUser := g.CreateMessangePackByUserFromEventBuffer()

        for userId, messagePack := range messagePackByUser </span><span class="cov0" title="0">{
                if userId == user.Id </span><span class="cov0" title="0">{
                        r := []any{response}
                        messagePack.Messages = append(r, messagePack.Messages...)
                }</span>
                <span class="cov0" title="0">messageString, err := json.Marshal(messagePack)
                if messageString == nil || err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                <span class="cov0" title="0">responseByUser[userId] = messageString</span>
        }

        <span class="cov0" title="0">return responseByUser</span>
}

func (g *Game) CreateMessangePackByUserFromEventBuffer() map[string]MessagePack <span class="cov0" title="0">{
        result := make(map[string]MessagePack)
        for _, user := range g.Users </span><span class="cov0" title="0">{
                events := g.GameEventBuffer

                eventPackEvents := []any{}
                for _, event := range events </span><span class="cov0" title="0">{

                        estring, _ := json.Marshal(event)
                        fmt.Println("---------------------" + user.Id)
                        fmt.Println(string(estring))
                        fmt.Println("---------------------")
                        eventPackEvents = append(eventPackEvents, event)
                }</span>
                <span class="cov0" title="0">result[user.Id] = MessagePack{
                        Messages:  eventPackEvents,
                        GameState: gameToGameStateResponse(g, user),
                }</span>
        }

        <span class="cov0" title="0">g.GameEventBuffer = []GameEventContainer{}

        return result</span>
}

func generateDeck() []Card <span class="cov4" title="10">{
        deck := make([]Card, 36)
        i := 0

        for suit := 1; suit &lt;= 4; suit++ </span><span class="cov6" title="40">{
                for rank := 6; rank &lt;= 14; rank++ </span><span class="cov10" title="360">{
                        deck[i] = Card{
                                Suit: suit,
                                Rank: rank,
                        }
                        i++
                }</span>
        }

        <span class="cov4" title="10">return deck</span>
}

func shackeCards(cards []Card) <span class="cov4" title="10">{
        rand.Shuffle(len(cards), func(i, j int) </span><span class="cov9" title="350">{
                cards[i], cards[j] = cards[j], cards[i]
        }</span>)
}

func (g *Game) nextUser(userId string) (*User, error) <span class="cov5" title="16">{
        user, err := g.getUserById(userId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="16">nextPlace := user.Place + 1
        if nextPlace &gt;= len(g.Users) </span><span class="cov3" title="7">{
                nextPlace = 0
        }</span>

        <span class="cov5" title="16">return g.Users[nextPlace], nil</span>
}

func (g *Game) getUserById(userId string) (*User, error) <span class="cov7" title="79">{
        for _, u := range g.Users </span><span class="cov8" title="138">{
                if u.Id == userId </span><span class="cov7" title="79">{
                        return u, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, errors.New("Not found")</span>
}

func (g *Game) getUserByPlace(place int) (*User, error) <span class="cov2" title="2">{
        for _, u := range g.Users </span><span class="cov3" title="4">{
                if u.Place == place </span><span class="cov2" title="2">{
                        return u, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, errors.New("Not found")</span>
}

func (g *Game) getObservingUsers() []*User <span class="cov2" title="2">{
        users := make([]*User, 0, len(g.Users)-2)
        if len(g.Users) == 2 </span><span class="cov0" title="0">{
                return users
        }</span>

        <span class="cov2" title="2">for _, u := range g.Users </span><span class="cov3" title="6">{
                if u.Id != g.AttackingId &amp;&amp; u.Id != g.DefendingId </span><span class="cov2" title="2">{
                        users = append(users, u)
                }</span>
        }

        <span class="cov2" title="2">return users</span>
}

func getCardBySuitAndRank(cards []Card, suit int, rank int) (Card, error) <span class="cov5" title="16">{
        for i := range cards </span><span class="cov5" title="16">{
                if cards[i].Suit == suit &amp;&amp; cards[i].Rank == rank </span><span class="cov5" title="16">{
                        return cards[i], nil
                }</span>
        }

        <span class="cov0" title="0">return Card{}, errors.New("Not found")</span>
}

func tableHasCardRank(tableCards []TableCard, rank int) bool <span class="cov2" title="3">{
        for i := range tableCards </span><span class="cov2" title="3">{
                if tableCards[i].Rank == rank </span><span class="cov2" title="2">{
                        return true
                }</span>

                <span class="cov1" title="1">beatOffCard := tableCards[i].BeatOff
                if beatOffCard != nil </span><span class="cov0" title="0">{
                        if beatOffCard.Rank == rank </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        <span class="cov1" title="1">return false</span>
}

func tableHasCard(tableCards []TableCard, suit int, rank int) bool <span class="cov3" title="4">{
        for i := range tableCards </span><span class="cov3" title="4">{
                if tableCards[i].Suit == suit &amp;&amp; tableCards[i].Rank == rank </span><span class="cov3" title="4">{
                        return true
                }</span>

                <span class="cov0" title="0">beatOffCard := tableCards[i].BeatOff
                if beatOffCard != nil </span><span class="cov0" title="0">{
                        if beatOffCard.Suit == suit &amp;&amp; beatOffCard.Rank == rank </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        <span class="cov0" title="0">return false</span>
}

func CardGreater(fsuit int, frank int, ssuit int, srank int, trump int) bool <span class="cov3" title="7">{
        if fsuit == trump &amp;&amp; ssuit != trump </span><span class="cov3" title="6">{
                return true
        }</span> else<span class="cov1" title="1"> if fsuit != trump &amp;&amp; ssuit == trump </span><span class="cov0" title="0">{
                return false
        }</span> else<span class="cov1" title="1"> {
                return frank &gt; srank
        }</span>
}

func allCardBeatOff(cards []TableCard) bool <span class="cov3" title="7">{
        for i := range cards </span><span class="cov3" title="7">{
                if cards[i].BeatOff == nil </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov3" title="7">return true</span>
}

func tableCardsToCards(tableCards []TableCard) []Card <span class="cov1" title="1">{
        cards := []Card{}

        for i := range tableCards </span><span class="cov2" title="3">{
                cards = append(cards, Card{Suit: tableCards[i].Suit, Rank: tableCards[i].Rank})
                if tableCards[i].BeatOff != nil </span><span class="cov1" title="1">{
                        cards = append(cards, *tableCards[i].BeatOff)
                }</span>
        }

        <span class="cov1" title="1">return cards</span>
}

func contains[T comparable](slice []T, element T) bool <span class="cov6" title="39">{
        for _, v := range slice </span><span class="cov5" title="16">{
                if v == element </span><span class="cov1" title="1">{
                        return true
                }</span>
        }
        <span class="cov6" title="38">return false</span>
}

func cardInfo(cards []Card) string <span class="cov0" title="0">{
        result := ""
        for _, card := range cards </span><span class="cov0" title="0">{
                result += fmt.Sprintf("Card |suit:%d |rank:%d\n", card.Suit, card.Rank)
        }</span>
        <span class="cov0" title="0">return result</span>
}

func (g *Game) AddEventToBuffer(event GameEventContainer) <span class="cov7" title="55">{
        g.GameEventBuffer = append(g.GameEventBuffer, event)
}</span>

func (g *Game) EndAttack(switchUsers bool) <span class="cov3" title="5">{
        attacker, _ := g.getUserById(g.AttackingId)
        defender, _ := g.getUserById(g.DefendingId)

        otherUsers := make([]*User, len(g.Users))
        copy(otherUsers, g.Users)
        otherUsers = removeUser(otherUsers, attacker.Id, defender.Id)

        g.AddCardsToUser(attacker)
        for _, user := range otherUsers </span><span class="cov2" title="2">{
                g.AddCardsToUser(user)
        }</span>
        <span class="cov3" title="5">g.AddCardsToUser(defender)

        if switchUsers </span><span class="cov3" title="4">{
                newDefending, _ := g.nextUser(g.DefendingId)

                g.AttackingId = g.DefendingId
                g.DefendingId = newDefending.Id
        }</span>

        <span class="cov3" title="5">g.TableCards = []TableCard{}
        g.StopAttackTimer()
        g.StopDefendTimer()
        endEvent := NewEndAttackEvent()
        g.AddEventToBuffer(endEvent)</span>
}

func (g *Game) AddCardsToUser(user *User) <span class="cov4" title="12">{
        if len(user.Cards) &gt;= 6 </span><span class="cov3" title="5">{
                return
        }</span>

        <span class="cov3" title="7">user.TakenCards = []Card{}

        addCardAmount := 6 - len(user.Cards)
        for range addCardAmount </span><span class="cov4" title="9">{
                card, err := g.TakeCardFromDeck()
                if err != nil </span><span class="cov2" title="2">{
                        break</span>
                }

                <span class="cov3" title="7">user.Cards = append(user.Cards, card)
                user.TakenCards = append(user.TakenCards, card)</span>
        }
}

func (g *Game) TakeCardFromDeck() (Card, error) <span class="cov4" title="9">{
        if len(g.Deck) &lt;= 0 </span><span class="cov2" title="2">{
                return Card{}, errors.New("Deck is empty")
        }</span>

        <span class="cov3" title="7">card := g.Deck[len(g.Deck)-1]
        g.Deck = g.Deck[:len(g.Deck)-1]

        return card, nil</span>
}

func removeUser(users []*User, userIds ...string) []*User <span class="cov3" title="5">{
        result := make([]*User, 0, len(users))
        for _, user := range users </span><span class="cov4" title="12">{
                shouldRemove := false
                for _, removeUserId := range userIds </span><span class="cov5" title="19">{
                        if user.Id == removeUserId </span><span class="cov4" title="10">{
                                shouldRemove = true
                                break</span>
                        }
                }
                <span class="cov4" title="12">if !shouldRemove </span><span class="cov2" title="2">{
                        result = append(result, user)
                }</span>
        }
        <span class="cov3" title="5">return result</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package core

import "time"

const (
        EVENT_NONE                       = "NONE"
        EVENT_START                      = "START"
        EVENT_READY                      = "READY"
        EVENT_ATTACK                     = "ATTACK"
        EVENT_DEFEND                     = "DEFEND"
        EVENT_END_ATTACK                 = "END_ATTACK"
        EVENT_TAKE_ALL_CARDS             = "TAKE_ALL_CARDS"
        EVENT_ATTACK_TIMER_NOT_COMPLETED = "ATTACK_TIMER_NOT_COMPLETED"
        EVENT_DEFEND_TIMER_NOT_COMPLETED = "DEFEND_TIMER_NOT_COMPLETED"
        EVENT_ATTACK_TIMER_COMPLETED     = "ATTACK_TIMER_COMPLETED"
        EVENT_DEFEND_TIMER_COMPLETED     = "DEFEND_TIMER_COMPLETED"
        EVENT_USER_EXIT                  = "USER_EXIT" // connection loss
        EVENT_USER_HAS_FINISHED          = "USER_HAS_FINISHED"
        EVENT_END_GAME                   = "END_GAME"
)

type GameResult string

const (
        GameResultWin         GameResult = "win"
        GameResultDraw        GameResult = "draw"
        GameResultInterrupted GameResult = "interrupted"
)

type GameEventContainer any

// type GameEven

type GameEvent struct {
        Event string `json:"event"`
}

type StartGameEvent struct {
        GameEvent
}

type ReadyEvent struct {
        GameEvent
        UserId string `json:"user_id"`
}

type AttackEvent struct {
        GameEvent
        Card       Card   `json:"card"`
        AttackerId string `json:"attacker_id"`
}

type DefendEvent struct {
        GameEvent
        TargetCard Card   `json:"target_card"`
        UserCard   Card   `json:"user_card"`
        DefenderId string `json:"defender_id"`
}

type TakeAllCardsEvent struct {
        GameEvent
        UserId string `json:"user_id"`
}

type EndAttackEvent struct {
        GameEvent
}

type AttackTimerStateEvent struct {
        GameEvent
        Completed  bool       `json:"completed"`
        TimerEndAt *time.Time `json:"timer_end_at"`
}

type DefendTimerStateEvent struct {
        GameEvent
        Completed  bool       `json:"completed"`
        TimerEndAt *time.Time `json:"timer_end_at"`
}

type EndGameEvent struct {
        GameEvent
        GameResult GameResult `json:"game_result"`
}

func NewReadyEvent(userId string) ReadyEvent <span class="cov8" title="22">{
        return ReadyEvent{
                GameEvent: GameEvent{
                        Event: EVENT_READY,
                },
                UserId: userId,
        }
}</span>

func NewStartGameEvent(gameState GameStateResponse) StartGameEvent <span class="cov6" title="10">{
        return StartGameEvent{
                GameEvent: GameEvent{
                        Event: EVENT_START,
                },
        }
}</span>

func NewAttackEvent(card Card, attackerId string) AttackEvent <span class="cov6" title="10">{
        return AttackEvent{
                GameEvent: GameEvent{
                        Event: EVENT_ATTACK,
                },
                Card:       card,
                AttackerId: attackerId,
        }
}</span>

func NewDefendEvent(
        userCard Card,
        targetCard Card,
        defenderId string,
        gameState GameStateResponse,
) DefendEvent <span class="cov3" title="3">{
        return DefendEvent{
                GameEvent: GameEvent{
                        Event: EVENT_DEFEND,
                },
                UserCard:   userCard,
                TargetCard: targetCard,
                DefenderId: defenderId,
        }
}</span>

func NewTakeAllCardsEvent(userId string) TakeAllCardsEvent <span class="cov1" title="1">{
        return TakeAllCardsEvent{
                GameEvent: GameEvent{
                        Event: EVENT_TAKE_ALL_CARDS,
                },
                UserId: userId,
        }
}</span>

func NewEndAttackEvent() EndAttackEvent <span class="cov5" title="6">{
        return EndAttackEvent{
                GameEvent: GameEvent{
                        Event: EVENT_END_ATTACK,
                },
        }
}</span>

func NewAttackTimerStateEvent(
        completed bool,
        timerEndAt *time.Time,
) AttackTimerStateEvent <span class="cov1" title="1">{
        return AttackTimerStateEvent{
                GameEvent: GameEvent{
                        Event: EVENT_END_ATTACK,
                },
                Completed:  completed,
                TimerEndAt: timerEndAt,
        }
}</span>

func NewDefendTimerStateEvent(
        completed bool,
        timerEndAt *time.Time,
) DefendTimerStateEvent <span class="cov1" title="1">{
        return DefendTimerStateEvent{
                GameEvent: GameEvent{
                        Event: EVENT_END_ATTACK,
                },
                Completed:  completed,
                TimerEndAt: timerEndAt,
        }
}</span>

func NewEndGameEvent(
        result GameResult,
) EndGameEvent <span class="cov1" title="1">{ // TODO: handle many users. Now handle only 2
        return EndGameEvent{
                GameEvent: GameEvent{
                        Event: EVENT_END_GAME,
                },
                GameResult: result,
        }
}</span>

func GameEventToType(e GameEventContainer) string <span class="cov10" title="45">{
        switch event := e.(type) </span>{
        case ReadyEvent:<span class="cov8" title="20">
                return event.Event</span>
        case StartGameEvent:<span class="cov6" title="9">
                return event.Event</span>
        case AttackEvent:<span class="cov5" title="7">
                return event.Event</span>
        case DefendEvent:<span class="cov2" title="2">
                return event.Event</span>
        case EndAttackEvent:<span class="cov4" title="5">
                return event.Event</span>
        case TakeAllCardsEvent:<span class="cov1" title="1">
                return event.Event</span>
        case EndGameEvent:<span class="cov1" title="1">
                return event.Event</span>
        case AttackTimerStateEvent:<span class="cov0" title="0">
                return event.Event</span>
        case DefendTimerStateEvent:<span class="cov0" title="0">
                return event.Event</span>
        }

        <span class="cov0" title="0">return EVENT_NONE</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package core

const (
        ACTION_READY              = "ACTION_READY"
        ACTION_ATTACK             = "ACTION_ATTACK"
        ACTION_DEFEND             = "ACTION_DEFEND"
        ACTION_END_ATTACK         = "ACTION_END_ATTACK"
        ACTION_TAKE_ALL_CARDS     = "ACTION_TAKE_ALL_CARDS"
        ACTION_CHECK_ATTACK_TIMER = "ACTION_CHECK_ATTACK_TIMER" // TODO:
        ACTION_CHECK_DEFEND_TIMER = "ACTION_CHECK_DEFEND_TIMER" // TODO:
)

const (
        ERROR_EMPTY                                         = ""
        ERROR_SERVER                                        = "SERVER_ERROR"
        ERROR_BAD_REQUEST                                   = "BAD_REQUEST"
        ERROR_USER_ALREADY_READY                            = "USER_ALREADY_READY"
        ERROR_NOT_YOUR_TURN                                 = "NOT_YOUR_TURN"
        ERROR_INCORRECT_CARD                                = "INCORRECT_CARD"
        ERROR_USER_NO_HAS_CARD                              = "USER_NO_HAS_CARD"
        ERROR_ATTACK_TIME_OVER                              = "ATTACK_TIME_OVER"
        ERROR_DEFEND_TIME_OVER                              = "DEFEND_TIME_OVER"
        ERROR_NO_SAME_RANK_CARD_IN_TABLE                    = "NO_SAME_RANK_CARD_IN_TABLE"
        ERROR_NOT_FOUND_CART_ON_TABLE                       = "NOT_FOUND_CART_ON_TABLE"
        ERROR_TARGET_CARD_GREATER_THEN_YOUR                 = "TARGET_CARD_GREATER_THEN_YOUR"
        ERROR_GAME_SHOULD_BE_STARTED                        = "GAME_SHOULD_BE_STARTED"
        ERROR_CANNOT_END_ATTACK_IN_FIRST_TURN               = "CANNOT_END_ATTACK_IN_FIRST_TURN"
        ERROR_ALL_CARD_SHOULD_BE_BEAT_OFF_BEFORE_END_ATTACK = "ALL_CARD_SHOULD_BE_BEAT_OFF_BEFORE_END_ATTACK"
        ERROR_TABLE_HOLDS_ONLY_SIX_CARDS                    = "TABLE_HOLDS_ONLY_SIX_CARDS"
        ERROR_DEFENDER_NO_CARDS                             = "DEFENDER_NO_CARDS"
        ERROR_ALREADY_END_ATTACK                            = "ALREADY_END_ATTACK" // TODO: implement
        ERROR_UNREGISTERED_ACTION                           = "UNREGISTERED_ACTION"
)

type MessagePack struct {
        Messages  []any             `json:"messages"`
        GameState GameStateResponse `json:"game_state"`
}

func gameToGameStateResponse(game *Game, targetUser *User) GameStateResponse <span class="cov8" title="58">{
        return GameStateResponse{
                Me:          *targetUser,
                Users:       usersToUserResponses(game.Users),
                AttackingId: game.AttackingId,
                DefendingId: game.DefendingId,
                DeckLength:  len(game.Deck),
                TrumpSuit:   game.TrumpSuit,
                TableCards:  game.TableCards,
        }
}</span>

func usersToUserResponses(users []*User) []UserResponse <span class="cov8" title="58">{
        userResponses := make([]UserResponse, len(users))
        for i := 0; i &lt; len(users); i++ </span><span class="cov10" title="133">{
                userResponses[i] = userToUserResponse(*users[i])
        }</span>

        <span class="cov8" title="58">return userResponses</span>
}

func userToUserResponse(user User) UserResponse <span class="cov10" title="133">{
        return UserResponse{
                Id:               user.Id,
                Name:             user.Name,
                CardLength:       len(user.Cards),
                TakenCardsLength: len(user.TakenCards),
        }
}</span>

type GameStateResponse struct {
        Me          User           `json:"me"`
        Users       []UserResponse `json:"users"`
        AttackingId string         `json:"attacking_id"`
        DefendingId string         `json:"defending_id"`
        DeckLength  int            `json:"deck_length"`
        TrumpSuit   int            `json:"trump_suit"`
        TableCards  []TableCard    `json:"table_cards"`
}

// Requeste messages
type Command struct {
        GameId string `json:"game_id"`
        Action string `json:"action"`
        UserId string `json:"user_id"`
}

type AttackCommand struct {
        Card Card `json:"card"`
        Command
}

type DefendCommand struct {
        TargetCard Card `json:"target_card"`
        UserCard   Card `json:"user_card"`
        Command
}

// Response messages
type CommandResponse struct {
        Error   string            `json:"error"`
        Command any               `json:"command"`
        State   GameStateResponse `json:"state"`
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package grpc

import (
        "context"

        "github.com/MommusWinner/MicroDurak/internal/contracts/game/v1"
        "github.com/MommusWinner/MicroDurak/internal/services/game/config"
        "github.com/MommusWinner/MicroDurak/internal/services/game/controller"
)

type GameServer struct {
        game.UnimplementedGameServer
        Config         *config.Config
        GameController *controller.GameController
}

func NewGameServer(gameController *controller.GameController, config *config.Config) *GameServer <span class="cov0" title="0">{
        return &amp;GameServer{GameController: gameController, Config: config}
}</span>

func (gs *GameServer) CreateGame(
        ctx context.Context,
        req *game.CreateGameRequest,
) (*game.CreateGameResponse, error) <span class="cov0" title="0">{
        createdGame, err := gs.GameController.CreateGame(req.UserIds)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp := &amp;game.CreateGameResponse{GameId: createdGame.Id}
        return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package main

import (
        "context"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/MommusWinner/MicroDurak/internal/contracts/game/v1"
        "github.com/MommusWinner/MicroDurak/internal/contracts/players/v1"
        "github.com/MommusWinner/MicroDurak/internal/services/matchmaker"
        "github.com/MommusWinner/MicroDurak/internal/services/matchmaker/config"
        "github.com/MommusWinner/MicroDurak/internal/services/matchmaker/delivery/http"
        "github.com/MommusWinner/MicroDurak/internal/services/matchmaker/types"
        "github.com/labstack/echo/v4"
        "github.com/redis/go-redis/v9"
        echoSwagger "github.com/swaggo/echo-swagger"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"

        _ "github.com/MommusWinner/MicroDurak/internal/services/matchmaker/delivery/http/docs"
)

func run(ctx context.Context, e *echo.Echo) error <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(ctx)
        defer cancel()

        config, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">opt, err := redis.ParseURL(config.RedisURL)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">redisClient := redis.NewClient(opt)

        opts := []grpc.DialOption{
                grpc.WithTransportCredentials(insecure.NewCredentials()),
        }

        playerClientConn, err := grpc.NewClient(config.PlayersURL, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">playerClient := players.NewPlayersClient(playerClientConn)

        gameClientConn, err := grpc.NewClient(config.GameURL, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">gameClient := game.NewGameClient(gameClientConn)

        queueChan := make(chan types.MatchChan)
        cancelChan := make(chan types.MatchCancel)
        m := matchmaker.New(queueChan, cancelChan, config, redisClient, gameClient)

        http.AddRoutes(e, queueChan, cancelChan, config, playerClient)

        errChan := make(chan error, 2)

        go func() </span><span class="cov0" title="0">{ errChan &lt;- m.Start(ctx) }</span>()
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{ errChan &lt;- e.Start(":" + config.Port) }</span>()

        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)

        shutdownServices := func(shutdownErr error) error </span><span class="cov0" title="0">{
                cancel()

                shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 10*time.Second)
                defer shutdownCancel()
                if err := e.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                        e.Logger.Errorf("Failed to shutdown Echo server: %v", err)
                        // Return original error if exists, otherwise return shutdown error
                        if shutdownErr != nil </span><span class="cov0" title="0">{
                                return shutdownErr
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
                <span class="cov0" title="0">return shutdownErr</span>
        }

        <span class="cov0" title="0">select </span>{
        case err := &lt;-errChan:<span class="cov0" title="0">
                return shutdownServices(err)</span>
        case &lt;-quit:<span class="cov0" title="0">
                e.Logger.Info("\nShutting down servers...")
                // Graceful shutdown without initial error
                return shutdownServices(nil)</span>
        }
}

// @title Matchmaker Service API
// @version 1.0
// @description API for handling match making functionality
// @host localhost:3000
// @basePath /api/v1
func main() <span class="cov0" title="0">{
        e := echo.New()

        e.GET("/swagger/*", echoSwagger.WrapHandler)

        ctx := context.Background()
        if err := run(ctx, e); err != nil </span><span class="cov0" title="0">{
                e.Logger.Fatal(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package config

import (
        "github.com/alecthomas/kong"
)

type Config struct {
        JWTPublic  string `help:"Base64 Private key for the jwt"          env:"JWT_PUBLIC" required:"true"`
        Port       string `help:"Port to listen on"                       env:"PORT" default:"8080"`
        RedisURL   string `help:"Redis connection URL"                    env:"REDIS_URL" required:"true"`
        PlayersURL string `help:"URL pointing to the Players Service"  env:"PLAYERS_URL" required:"true"`
        GameURL    string `help:"URL pointing to the Game Service"  env:"GAME_URL" required:"true"`
        PodName    string `help:"K8s pod name" env:"POD_NAME" default:"unknown"`
        Namespace  string `help:"K8s namespace" env:"NAMESPACE" default:"unknown"`
        LogLevel   string `help:"Log level (debug, info, warn, error)"    env:"LOG_LEVEL" default:"info"`
}

func Load() (*Config, error) <span class="cov0" title="0">{
        cfg := &amp;Config{}
        parser, err := kong.New(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Parse command-line flags, environment variables, and config file
        <span class="cov0" title="0">_, err = parser.Parse(nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package http

import (
        "github.com/labstack/echo/v4"
        "github.com/prometheus/client_golang/prometheus/promhttp"

        "github.com/MommusWinner/MicroDurak/internal/contracts/players/v1"
        "github.com/MommusWinner/MicroDurak/internal/services/matchmaker/config"
        "github.com/MommusWinner/MicroDurak/internal/services/matchmaker/types"
        "github.com/MommusWinner/MicroDurak/lib/jwt"
)

func AddRoutes(
        e *echo.Echo,
        queue chan&lt;- types.MatchChan,
        cancel chan&lt;- types.MatchCancel,
        config *config.Config,
        playersClient players.PlayersClient,
) <span class="cov0" title="0">{
        h := Handler{
                Queue:         queue,
                Cancel:        cancel,
                Config:        config,
                PlayersClient: playersClient,
        }
        e.GET("/api/v1/matchmaker/find-match", h.FindMatch, jwt.AuthMiddleware(config.JWTPublic))
        e.GET("/metrics", echo.WrapHandler(promhttp.Handler()))
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/matchmaker/find-match": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Initiates a WebSocket connection for players looking for a match",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "matchmaker"
                ],
                "summary": "Find a match via WebSocket",
                "responses": {
                    "101": {
                        "description": "WebSocket upgrade successful"
                    },
                    "401": {
                        "description": "Unauthorized - Invalid JWT token or unknown player"
                    },
                    "500": {
                        "description": "Internal server error"
                    }
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "localhost:3000",
        BasePath:         "/api/v1",
        Schemes:          []string{},
        Title:            "Matchmaker Service API",
        Description:      "API for handling match making functionality",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package http

import (
        "encoding/json"
        "net/http"
        "strconv"
        "time"

        "github.com/MommusWinner/MicroDurak/internal/contracts/players/v1"
        "github.com/MommusWinner/MicroDurak/internal/services/matchmaker/config"
        "github.com/MommusWinner/MicroDurak/internal/services/matchmaker/metrics"
        "github.com/MommusWinner/MicroDurak/internal/services/matchmaker/types"
        "github.com/gorilla/websocket"
        "github.com/labstack/echo/v4"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

var (
        upgrader = websocket.Upgrader{}
)

type FindMatchResponse struct {
        // MatchStatus string
        Status    string `json:"status"`
        GameId    string `json:"game_id,omitempty"`
        GroupSize int    `json:"group_size,omitzero"`
}

type Handler struct {
        Queue         chan&lt;- types.MatchChan
        Cancel        chan&lt;- types.MatchCancel
        Config        *config.Config
        PlayersClient players.PlayersClient
}

// FindMatch handles WebSocket connections for players looking for matches
// @Summary Find a match via WebSocket
// @Description Initiates a WebSocket connection for players looking for a match
// @Tags matchmaker
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 101 "WebSocket upgrade successful"
// @Failure 401 "Unauthorized - Invalid JWT token or unknown player"
// @Failure 500 "Internal server error"
// @Router /matchmaker/find-match [get]
func (h *Handler) FindMatch(c echo.Context) error <span class="cov0" title="0">{
        start := time.Now()
        var err error

        defer func() </span><span class="cov0" title="0">{
                duration := time.Since(start).Seconds()
                var statusCode int

                // Determine status code from error if available
                if httpErr, ok := err.(*echo.HTTPError); ok </span><span class="cov0" title="0">{
                        statusCode = httpErr.Code
                }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        statusCode = http.StatusInternalServerError
                }</span>

                <span class="cov0" title="0">metrics.SearchDuration.WithLabelValues(h.Config.PodName, h.Config.Namespace).Observe(duration)

                metrics.HTTPRequestsTotal.WithLabelValues(
                        c.Request().Method,
                        c.Path(),
                        strconv.Itoa(statusCode),
                        h.Config.PodName,
                        h.Config.Namespace,
                ).Inc()</span>
        }()

        <span class="cov0" title="0">ctx := c.Request().Context()

        playerId, ok := c.Get("playerId").(string)
        if !ok </span><span class="cov0" title="0">{
                panic("Missing jwt middleware")</span>
        }

        <span class="cov0" title="0">player, err := h.PlayersClient.GetPlayer(ctx, &amp;players.GetPlayerRequest{Id: playerId})
        if err != nil </span><span class="cov0" title="0">{
                s := status.Convert(err)
                if s.Code() == codes.NotFound </span><span class="cov0" title="0">{
                        return echo.NewHTTPError(http.StatusUnauthorized, "Unknown Player")
                }</span>
                <span class="cov0" title="0">c.Logger().Error(err)
                return err</span>
        }

        <span class="cov0" title="0">ws, err := upgrader.Upgrade(c.Response(), c.Request(), nil)
        if err != nil </span><span class="cov0" title="0">{
                metrics.WebsocketUpgradeErrors.WithLabelValues(h.Config.PodName, h.Config.Namespace).Inc()
                return err
        }</span>
        <span class="cov0" title="0">defer ws.Close()

        doneChan := make(chan bool, 1)
        closeHandler := ws.CloseHandler()
        ws.SetCloseHandler(func(code int, text string) error </span><span class="cov0" title="0">{
                select </span>{
                case doneChan &lt;- true:<span class="cov0" title="0"></span>
                default:<span class="cov0" title="0"></span>
                }
                <span class="cov0" title="0">err := closeHandler(code, text)
                return err</span>
        })

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        select </span>{
                        case doneChan &lt;- true:<span class="cov0" title="0"></span>
                        default:<span class="cov0" title="0"></span>
                        }
                }()
                <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                        if _, _, err := ws.ReadMessage(); err != nil </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
        }()

        <span class="cov0" title="0">metrics.PlayersSearching.WithLabelValues(h.Config.PodName, h.Config.Namespace).Inc()
        defer metrics.PlayersSearching.WithLabelValues(h.Config.PodName, h.Config.Namespace).Dec()

        returnChan := make(chan types.MatchResponse)
        h.Queue &lt;- types.MatchChan{
                PlayerId:   playerId,
                Rating:     int(player.Rating),
                SentTime:   time.Now(),
                ReturnChan: returnChan,
        }

        for </span><span class="cov0" title="0">{
                select </span>{
                case matchReturn := &lt;-returnChan:<span class="cov0" title="0">
                        switch matchReturn.Status </span>{
                        case types.MatchCreated:<span class="cov0" title="0">
                                roomId := matchReturn.RoomId
                                resp := FindMatchResponse{
                                        Status: types.MatchCreated.String(),
                                        GameId: roomId,
                                }

                                respString, _ := json.Marshal(resp)
                                ws.WriteMessage(websocket.TextMessage, respString)

                                closeMsg := websocket.FormatCloseMessage(websocket.CloseNormalClosure, "Connection closed")
                                err = ws.WriteControl(websocket.CloseMessage, closeMsg, time.Now().Add(time.Second))
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov0" title="0">return nil</span>
                        case types.MatchError:<span class="cov0" title="0">
                                status := FindMatchResponse{
                                        Status: matchReturn.Status.String(),
                                }

                                stautsString, _ := json.Marshal(status)

                                ws.WriteMessage(websocket.TextMessage, stautsString)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov0" title="0">return matchReturn.Error</span>
                        default:<span class="cov0" title="0">
                                status := FindMatchResponse{
                                        Status:    matchReturn.Status.String(),
                                        GroupSize: matchReturn.GroupSize,
                                }

                                stautsString, _ := json.Marshal(status)

                                err := ws.WriteMessage(websocket.TextMessage, stautsString)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                case &lt;-doneChan:<span class="cov0" title="0">
                        h.Cancel &lt;- types.MatchCancel{PlayerId: playerId}
                        return nil</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package matchmaker

import (
        "context"
        "errors"
        "time"

        "github.com/MommusWinner/MicroDurak/internal/contracts/game/v1"
        "github.com/MommusWinner/MicroDurak/internal/services/matchmaker/config"
        rc "github.com/MommusWinner/MicroDurak/internal/services/matchmaker/redis"
        "github.com/MommusWinner/MicroDurak/internal/services/matchmaker/types"
        "github.com/redis/go-redis/v9"
)

const increaceRangeAfter = 5
const increaceRangeBy = 100
const groupSize = 2

// PlayerClientInterface   PlayerClient ( )
type PlayerClientInterface interface {
        GetPlayer(ctx context.Context, playerId string) (rc.RedisPlayer, error)
        AddPlayer(ctx context.Context, playerId string, rating int) (rc.RedisPlayer, error)
        RemovePlayer(ctx context.Context, playerId string) error
        CountGroups(ctx context.Context) (int, error)
        ListGroupsRange(ctx context.Context, low, high int) ([]redis.Z, error)
        ListPlayersRange(ctx context.Context, low, high int) ([]redis.Z, error)
        AddToGroup(ctx context.Context, groupId int, member redis.Z) error
        AddGroup(ctx context.Context, players []redis.Z) error
        GetGroupLen(ctx context.Context, groupId int) (int, error)
        GetGrouppedPlayers(ctx context.Context, groupId int, groupSize int) ([]string, error)
        RemoveGroup(ctx context.Context, groupId int) error
        SetPlayerStatus(ctx context.Context, playerId string, status rc.PlayerStatus) error
}

type Matchmaker struct {
        queueChan      &lt;-chan types.MatchChan
        cancelChan     &lt;-chan types.MatchCancel
        queue          map[string]types.MatchChan
        config         *config.Config
        playerClient   PlayerClientInterface
        gameGRPCClient game.GameClient
}

func New(
        queueChan &lt;-chan types.MatchChan,
        cancelChan &lt;-chan types.MatchCancel,
        config *config.Config,
        redisClient *redis.Client,
        gameGRPCClient game.GameClient,
) *Matchmaker <span class="cov1" title="1">{
        playerClient := rc.NewClient(redisClient)
        queue := make(map[string]types.MatchChan)
        return &amp;Matchmaker{queueChan, cancelChan, queue, config, playerClient, gameGRPCClient}
}</span>

func (m *Matchmaker) Start(
        ctx context.Context,
) error <span class="cov0" title="0">{
        // fmt.Printf("Starting matchmaker\n\n")
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case matchChan := &lt;-m.queueChan:<span class="cov0" title="0">
                                m.queue[matchChan.PlayerId] = matchChan</span>
                        case cancelRequest := &lt;-m.cancelChan:<span class="cov0" title="0">
                                err := m.playerClient.RemovePlayer(ctx, cancelRequest.PlayerId)
                                if err != nil </span><span class="cov0" title="0">{
                                        panic(err)</span>
                                }
                                <span class="cov0" title="0">delete(m.queue, cancelRequest.PlayerId)</span>
                        }
                }
        }()

        <span class="cov0" title="0">ticker := time.NewTicker(1 * time.Second)
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        // fmt.Println("Cancelling matchmaker")
                        return nil</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if len(m.queue) == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">err := m.matchmake(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        // fmt.Println("----------")
                }
        }
}

func (m *Matchmaker) matchmake(ctx context.Context) error <span class="cov7" title="4">{
        for playerId, player := range m.queue </span><span class="cov7" title="4">{
                // fmt.Printf("Processing player: %s\n", playerId)

                storedPlayer, err := m.playerClient.GetPlayer(ctx, playerId)
                if err != nil </span><span class="cov1" title="1">{
                        storedPlayer, _ = m.playerClient.AddPlayer(ctx, playerId, player.Rating)
                }</span>
                // fmt.Printf("Status: %d\n", storedPlayer.Status)

                <span class="cov7" title="4">switch storedPlayer.Status </span>{
                case rc.StatusSearch:<span class="cov6" title="3">
                        player.ReturnChan &lt;- types.MatchResponse{
                                Status: types.MatchPending,
                        }

                        err := m.handleSearch(ctx, player)
                        if errors.Is(err, types.ErrGroupNotFound) </span><span class="cov6" title="3">{
                                continue</span>
                        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                case rc.StatusMoved:<span class="cov1" title="1">
                        player.ReturnChan &lt;- types.MatchResponse{
                                Status: types.MatchFoundGroup,
                        }

                        err := m.handleMoved(ctx, storedPlayer)
                        var gidError *types.ErrGroupTooSmall
                        if errors.As(err, &amp;gidError) </span><span class="cov1" title="1">{
                                // fmt.Println(err)
                                continue</span>
                        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                // fmt.Println("")
        }
        <span class="cov7" title="4">return nil</span>
}

func (m *Matchmaker) handleSearch(ctx context.Context, player types.MatchChan) error <span class="cov10" title="7">{
        scoreRange := int(max((time.Now().Unix()-player.SentTime.Unix())/increaceRangeAfter, 1) * increaceRangeBy)
        low := player.Rating - scoreRange
        high := player.Rating + scoreRange
        // fmt.Printf("Low %d; High %d\n", low, high)

        count, err := m.playerClient.CountGroups(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="7">if count &gt; 0 </span><span class="cov4" title="2">{
                groups, err := m.playerClient.ListGroupsRange(ctx, low, high)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov4" title="2">if len(groups) &gt; 0 </span><span class="cov1" title="1">{
                        groupId, err := rc.ParseGroupId(groups[0].Member.(string))
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov1" title="1">m.playerClient.AddToGroup(ctx, groupId, redis.Z{Score: float64(player.Rating), Member: player.PlayerId})
                        // fmt.Printf("Found group: %v\n", groups[0])
                        return nil</span>
                }
        } else<span class="cov8" title="5"> {
                players, err := m.playerClient.ListPlayersRange(ctx, low, high)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="5">if len(players) &lt;= 1 </span><span class="cov7" title="4">{
                        return types.ErrGroupNotFound
                }</span>
                // fmt.Printf("Found players: %v\n", players)

                <span class="cov1" title="1">err = m.playerClient.AddGroup(ctx, players[:min(groupSize, len(players))])
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov4" title="2">return nil</span>
}

func (m *Matchmaker) handleMoved(
        ctx context.Context,
        storedPlayer rc.RedisPlayer,
) error <span class="cov6" title="3">{
        len, err := m.playerClient.GetGroupLen(ctx, storedPlayer.Gid)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="3">if len &lt; groupSize </span><span class="cov4" title="2">{
                return types.NewGroupTooSmall(storedPlayer.Gid)
        }</span>

        <span class="cov1" title="1">grouppedPlayers, err := m.playerClient.GetGrouppedPlayers(ctx, storedPlayer.Gid, groupSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = m.playerClient.RemoveGroup(ctx, storedPlayer.Gid)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">gameId, err := m.gameGRPCClient.CreateGame(ctx, &amp;game.CreateGameRequest{UserIds: grouppedPlayers})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">response := types.MatchResponse{
                Status: types.MatchCreated,
                RoomId: gameId.GameId,
        }

        for _, grouppedPlayer := range grouppedPlayers </span><span class="cov4" title="2">{
                m.playerClient.SetPlayerStatus(ctx, grouppedPlayer, rc.StatusEmpty)

                // fmt.Printf("Sending to player: %s\n", grouppedPlayer)
                m.queue[grouppedPlayer].ReturnChan &lt;- response
                delete(m.queue, grouppedPlayer)
        }</span>
        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package redis

import (
        "context"
        "errors"
        "fmt"
        "strconv"
        "strings"
        "time"

        "github.com/redis/go-redis/v9"
)

const groupQueueKey = "matchmaking:queue:groups"
const playerQueueKey = "matchmaking:queue:players"

const groupMemFmt = "group:%d"

const groupsAmountKey = "matchmaking:groups:amount"

const groupKeyFmt = "matchmaking:group:%d"
const groupMembersKey = ":members"

const playerKeyFmt = "matchmaking:player:%s"
const playerStatusKey = ":status"
const playerGroupKey = ":group"

type PlayerStatus = int

type parseError struct {
        name string
}

func (e *parseError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("parse failed for %s", e.name)
}</span>

func newParseError(name string) *parseError <span class="cov0" title="0">{
        return &amp;parseError{name}
}</span>

const (
        StatusEmpty = iota
        StatusSearch
        StatusMoved
)

type RedisPlayer struct {
        Status PlayerStatus
        Id     string
        Gid    int
}

type PlayerClient struct {
        client *redis.Client
}

func NewClient(client *redis.Client) *PlayerClient <span class="cov0" title="0">{
        return &amp;PlayerClient{client}
}</span>

func ParseGroupId(groupString string) (int, error) <span class="cov0" title="0">{
        sep := strings.Split(groupString, ":")
        if len(sep) &lt; 2 </span><span class="cov0" title="0">{
                return 0, newParseError("group id")
        }</span>

        <span class="cov0" title="0">id, err := strconv.Atoi(sep[1])
        if err != nil </span><span class="cov0" title="0">{
                return 0, newParseError("group id")
        }</span>

        <span class="cov0" title="0">return id, nil</span>
}

func (pc *PlayerClient) GetPlayerScore(ctx context.Context, playerId string) (int, error) <span class="cov0" title="0">{
        score, err := pc.client.ZScore(ctx, playerQueueKey, playerId).Result()

        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return int(score), nil</span>
}

func (pc *PlayerClient) GetPlayer(ctx context.Context, playerId string) (RedisPlayer, error) <span class="cov0" title="0">{
        playerKey := fmt.Sprintf(playerKeyFmt, playerId)
        statusString, err := pc.client.Get(ctx, playerKey+playerStatusKey).Result()

        var player RedisPlayer

        if err != nil </span><span class="cov0" title="0">{
                return player, err
        }</span>

        <span class="cov0" title="0">status, err := strconv.Atoi(statusString)

        if err != nil </span><span class="cov0" title="0">{
                return player, err
        }</span>

        <span class="cov0" title="0">player.Status = status
        player.Id = playerId

        switch status </span>{
        case StatusSearch:<span class="cov0" title="0">
                return player, nil</span>
        case StatusMoved:<span class="cov0" title="0">
                gidString, err := pc.client.Get(ctx, playerKey+playerGroupKey).Result()
                if err != nil </span><span class="cov0" title="0">{
                        return RedisPlayer{}, err
                }</span>

                <span class="cov0" title="0">gid, err := strconv.Atoi(gidString)
                if err != nil </span><span class="cov0" title="0">{
                        return RedisPlayer{}, err
                }</span>

                <span class="cov0" title="0">player.Gid = gid

                return player, nil</span>
        }
        <span class="cov0" title="0">return player, errors.New("unknown player status")</span>
}

func (pc *PlayerClient) SetPlayerStatus(ctx context.Context, playerId string, status PlayerStatus) error <span class="cov0" title="0">{
        playerKey := fmt.Sprintf(playerKeyFmt, playerId)
        err := pc.client.Set(ctx, playerKey+playerStatusKey, status, 24*time.Hour).Err()

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (pc *PlayerClient) SetPlayerGroup(ctx context.Context, playerId string, group int) error <span class="cov0" title="0">{
        playerKey := fmt.Sprintf(playerKeyFmt, playerId)
        err := pc.client.Set(ctx, playerKey+playerGroupKey, group, 24*time.Hour).Err()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (pc *PlayerClient) AddPlayer(ctx context.Context, playerId string, score int) (RedisPlayer, error) <span class="cov0" title="0">{
        player := RedisPlayer{StatusEmpty, playerId, 0}

        err := pc.client.ZAdd(ctx, playerQueueKey, redis.Z{Score: float64(score), Member: playerId}).Err()
        if err != nil </span><span class="cov0" title="0">{
                return player, err
        }</span>

        <span class="cov0" title="0">err = pc.SetPlayerStatus(ctx, playerId, StatusSearch)
        if err != nil </span><span class="cov0" title="0">{
                return player, err
        }</span>

        <span class="cov0" title="0">player.Status = StatusSearch
        return player, nil</span>
}

func (pc *PlayerClient) ListPlayersRange(ctx context.Context, low int, high int) ([]redis.Z, error) <span class="cov0" title="0">{
        lows := fmt.Sprint(low)
        highs := fmt.Sprint(high)

        player, err := pc.client.ZRangeByScoreWithScores(ctx, playerQueueKey, &amp;redis.ZRangeBy{Min: lows, Max: highs}).Result()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return player, nil</span>
}

func (pc *PlayerClient) RemovePlayer(ctx context.Context, playerId string) error <span class="cov0" title="0">{
        player, err := pc.GetPlayer(ctx, playerId)
        if errors.Is(err, redis.Nil) </span><span class="cov0" title="0">{
                return nil
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">switch player.Status </span>{
        case StatusEmpty:<span class="cov0" title="0">
                return nil</span>
        case StatusSearch:<span class="cov0" title="0">
                err := pc.SetPlayerStatus(ctx, playerId, StatusEmpty)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">err = pc.client.ZRem(ctx, playerQueueKey, playerId).Err()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        case StatusMoved:<span class="cov0" title="0">
                err := pc.RemoveFromGroup(ctx, player.Gid, playerId)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">pc.SetPlayerStatus(ctx, playerId, StatusEmpty)
                return nil</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (pc *PlayerClient) AddGroup(ctx context.Context, players []redis.Z) error <span class="cov0" title="0">{
        members := make([]any, 0, len(players))
        for _, player := range players </span><span class="cov0" title="0">{
                members = append(members, player.Member)
        }</span>

        <span class="cov0" title="0">err := pc.client.ZRem(ctx, playerQueueKey, members...).Err()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">scoreSum := 0
        for _, player := range players </span><span class="cov0" title="0">{
                scoreSum += int(player.Score)
        }</span>

        <span class="cov0" title="0">scoreAvg := scoreSum / len(players)

        count, err := pc.client.Incr(ctx, groupsAmountKey).Result()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">playerIds := make([]string, len(players))
        for i, player := range players </span><span class="cov0" title="0">{
                id := player.Member.(string)

                playerIds[i] = id

                pc.SetPlayerStatus(ctx, id, StatusMoved)
                pc.SetPlayerGroup(ctx, id, int(count))
        }</span>

        <span class="cov0" title="0">groupKey := fmt.Sprintf(groupKeyFmt, count)
        err = pc.client.SAdd(ctx, groupKey+groupMembersKey, playerIds).Err()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">queueGroupKey := fmt.Sprintf(groupMemFmt, count)
        err = pc.client.ZAdd(ctx, groupQueueKey, redis.Z{Score: float64(scoreAvg), Member: queueGroupKey}).Err()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (pc *PlayerClient) CountGroups(ctx context.Context) (int, error) <span class="cov0" title="0">{
        count, err := pc.client.ZCard(ctx, groupQueueKey).Result()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return int(count), nil</span>
}

func (pc *PlayerClient) ListGroupsRange(ctx context.Context, low int, high int) ([]redis.Z, error) <span class="cov0" title="0">{
        lows := fmt.Sprint(low)
        highs := fmt.Sprint(high)
        player, err := pc.client.ZRangeByScoreWithScores(ctx, groupQueueKey, &amp;redis.ZRangeBy{Min: lows, Max: highs}).Result()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return player, err</span>
}

func (pc *PlayerClient) AddToGroup(ctx context.Context, groupId int, player redis.Z) error <span class="cov0" title="0">{
        playerId := player.Member.(string)

        groupKey := fmt.Sprintf(groupKeyFmt, groupId)
        groupQueueKey := fmt.Sprintf(groupMemFmt, groupId)

        pc.SetPlayerStatus(ctx, playerId, StatusMoved)
        pc.SetPlayerGroup(ctx, playerId, groupId)

        len, err := pc.GetGroupLen(ctx, groupId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">oldScore, err := pc.GetGroupScore(ctx, groupId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">newScore := (oldScore*len+int(player.Score))/len + 1

        err = pc.client.ZIncrBy(ctx, groupQueueKey, float64(newScore+oldScore), groupQueueKey).Err()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = pc.client.SAdd(ctx, groupKey+groupMembersKey, playerId).Err()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (pc *PlayerClient) GetGroupLen(ctx context.Context, groupId int) (int, error) <span class="cov0" title="0">{
        groupKey := fmt.Sprintf(groupKeyFmt, groupId)

        len, err := pc.client.SCard(ctx, groupKey+groupMembersKey).Result()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return int(len), err</span>
}

func (pc *PlayerClient) GetGrouppedPlayers(ctx context.Context, groupId int, amount int) ([]string, error) <span class="cov0" title="0">{
        groupKey := fmt.Sprintf(groupKeyFmt, groupId)
        players, err := pc.client.SMembers(ctx, groupKey+groupMembersKey).Result()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return players, err</span>
}

func (pc *PlayerClient) RemoveFromGroup(ctx context.Context, groupId int, playerId string) error <span class="cov0" title="0">{
        err := pc.client.SRem(ctx, groupQueueKey, playerId).Err()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (pc *PlayerClient) RemoveGroup(ctx context.Context, groupId int) error <span class="cov0" title="0">{
        groupMemKey := fmt.Sprintf(groupMemFmt, groupId)
        err := pc.client.ZRem(ctx, groupQueueKey, groupMemKey).Err()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">groupKey := fmt.Sprintf(groupKeyFmt, groupId)
        err = pc.client.Del(ctx, groupKey+groupMembersKey).Err()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (pc *PlayerClient) GetGroupScore(ctx context.Context, groupId int) (int, error) <span class="cov0" title="0">{
        groupKey := fmt.Sprintf(groupMemFmt, groupId)
        score, err := pc.client.ZScore(ctx, groupKey, groupKey).Result()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return int(score), err</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package types

import (
        "errors"
        "fmt"
)

var ErrGroupNotFound = errors.New("matchmaker: group not found")

type ErrGroupTooSmall struct {
        Gid int
}

func (e ErrGroupTooSmall) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("matchmaker: group %d too small found", e.Gid)
}</span>

func NewGroupTooSmall(gid int) error <span class="cov0" title="0">{
        return &amp;ErrGroupTooSmall{gid}
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package types

import "time"

type ItemStatus int

const (
        MatchPending ItemStatus = iota
        MatchFoundGroup
        MatchCreated
        MatchError
)

func (s ItemStatus) String() string <span class="cov0" title="0">{
        switch s </span>{
        case MatchPending:<span class="cov0" title="0">
                return "pending"</span>
        case MatchCreated:<span class="cov0" title="0">
                return "created"</span>
        case MatchFoundGroup:<span class="cov0" title="0">
                return "found_group"</span>
        case MatchError:<span class="cov0" title="0">
                return "error"</span>
        }
        <span class="cov0" title="0">return "unknown"</span>
}

type MatchResponse struct {
        Status    ItemStatus
        RoomId    string
        GroupSize int
        Error     error
}

type MatchCancel struct {
        PlayerId string
}

type MatchChan struct {
        PlayerId   string
        Rating     int
        SentTime   time.Time
        ReturnChan chan&lt;- MatchResponse
}
</pre>
		
		<pre class="file" id="file52" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {}
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "localhost:8090",
        BasePath:         "/api/v1",
        Schemes:          []string{},
        Title:            "Player Service API",
        Description:      "API for working with players",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package main

import (
        "os"
        "os/signal"
        "sync"
        "syscall"
        "time"

        "github.com/MommusWinner/MicroDurak/internal/services/players/core"

        _ "github.com/MommusWinner/MicroDurak/internal/services/players/delivery/http/docs" //  swagger 
)

// @title Player Service API
// @version 1.0
// @description API for working with players
// @host localhost:8090
// @basePath /api/v1
func main() <span class="cov0" title="0">{
        var wg sync.WaitGroup

        di := core.NewDi()
        server := core.NewHttpServer(di.Ctx, di.PlayerHandler)
        grpcServer := core.NewGrpcServer(di.Ctx, di.PlayerUseCase, di.MatchUseCase)

        wg.Add(2)
        go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                di.Ctx.Logger().Info("HTTP server starting...")
                server.Start()
        }</span>()
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                di.Ctx.Logger().Info("gRPC server starting...")
                grpcServer.Start()
        }</span>()

        <span class="cov0" title="0">sigs := make(chan os.Signal, 1)
        signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)
        &lt;-sigs

        di.Ctx.Logger().Info("Shutting down players service...")
        time.Sleep(time.Second)

        wg.Wait()
        di.Ctx.Logger().Info("Players service stopped gracefully")</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package connection

import (
        "context"
        "fmt"
        "time"

        "github.com/MommusWinner/MicroDurak/internal/database"
        "github.com/MommusWinner/MicroDurak/internal/services/players/domain"
        "github.com/MommusWinner/MicroDurak/internal/services/players/domain/infra"
        "github.com/MommusWinner/MicroDurak/internal/services/players/domain/repositories"
        "github.com/jackc/pgx/v5/pgxpool"
)

type connection struct {
        pool    *pgxpool.Pool
        queries *database.Queries

        userRepository  repositories.UserRepository
        matchRepository repositories.MatchRepository
}

func makeConnection(pool *pgxpool.Pool) *connection <span class="cov0" title="0">{
        queries := database.New(pool)

        return &amp;connection{
                pool:            pool,
                queries:         queries,
                matchRepository: NewMatchRepository(pool, queries),
                userRepository:  NewPlayerRepository(queries, pool),
        }
}</span>

func Make(cfg infra.Config) domain.Connection <span class="cov0" title="0">{
        pool, err := pgxpool.New(context.Background(), cfg.GetDatabaseURL())

        pool.Config().MaxConns = 20
        pool.Config().MinConns = 5
        pool.Config().MaxConnLifetime = time.Hour
        pool.Config().MaxConnIdleTime = 30 * time.Minute

        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("unable to open database due [%s]", err))</span>
        }

        <span class="cov0" title="0">return makeConnection(pool)</span>
}

func Close(conn domain.Connection) <span class="cov0" title="0">{
        c := conn.(*connection)
        c.pool.Close()
}</span>

func (c *connection) UserRepository() repositories.UserRepository <span class="cov0" title="0">{
        return c.userRepository
}</span>

func (c *connection) MatchRepository() repositories.MatchRepository <span class="cov0" title="0">{
        return c.matchRepository
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">package connection

import (
        "context"
        "fmt"

        "github.com/MommusWinner/MicroDurak/internal/database"
        "github.com/MommusWinner/MicroDurak/internal/services/players/domain/models"
        "github.com/MommusWinner/MicroDurak/internal/services/players/domain/repositories"
        "github.com/google/uuid"
        "github.com/jackc/pgx/v5/pgxpool"
)

type matchRepo struct {
        queries *database.Queries
        pool    *pgxpool.Pool
}

func NewMatchRepository(pool *pgxpool.Pool, queries *database.Queries) *matchRepo <span class="cov0" title="0">{
        return &amp;matchRepo{queries: queries, pool: pool}
}</span>

func (r *matchRepo) Add(ctx context.Context, playerCount int, gameResult models.GameResult) (*models.Match, error) <span class="cov0" title="0">{
        var result string = models.GameResult_name[int32(gameResult)]
        match, err := r.queries.CreateMatchResult(ctx, database.CreateMatchResultParams{PlayerCount: int16(playerCount), GameResult: database.GameResult(result)})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;models.Match{Id: match.ID, PlayerCount: int(match.PlayerCount), GameResult: gameResult}, nil</span>
}

func (r *matchRepo) AddPlayerToMatch(ctx context.Context, matchId, playerId uuid.UUID, playerPlace int, ratingChange int32) error <span class="cov0" title="0">{
        _, err := r.queries.AddPlayerPlacement(ctx, database.AddPlayerPlacementParams{
                MatchResultID: matchId,
                PlayerID:      playerId,
                PlayerPlace:   int16(playerPlace),
                RatingChange:  ratingChange,
        })

        return err
}</span>

func (r *matchRepo) GetById(ctx context.Context, id uuid.UUID) (*models.Match, error) <span class="cov0" title="0">{
        match, err := r.queries.GetMatchResultById(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">gameResult := models.GameResult_value[string(match.GameResult)]

        return &amp;models.Match{
                Id:          match.ID,
                PlayerCount: int(match.PlayerCount),
                GameResult:  models.GameResult(gameResult),
        }, nil</span>
}

func (r *matchRepo) GetAll(ctx context.Context) ([]models.Match, error) <span class="cov0" title="0">{
        matches, err := r.queries.GetAllMatchResults(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">result := make([]models.Match, len(matches))
        for i, match := range matches </span><span class="cov0" title="0">{
                gameResult := models.GameResult_value[string(match.GameResult)]
                result[i] = models.Match{
                        Id:          match.ID,
                        PlayerCount: int(match.PlayerCount),
                        GameResult:  models.GameResult(gameResult),
                }
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (r *matchRepo) GetPlayerPlacementsByMatchId(ctx context.Context, matchId uuid.UUID) ([]models.PlayerPlacementWithDetails, error) <span class="cov0" title="0">{
        placements, err := r.queries.GetPlayerPlacementsByMatchId(ctx, matchId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">result := make([]models.PlayerPlacementWithDetails, len(placements))
        for i, placement := range placements </span><span class="cov0" title="0">{
                result[i] = models.PlayerPlacementWithDetails{
                        PlayerId:      placement.PlayerID,
                        PlayerPlace:   int(placement.PlayerPlace),
                        RatingChange:  placement.RatingChange,
                        PlayerName:    placement.Name,
                        CurrentRating: placement.Rating,
                }
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (r *matchRepo) WithTransaction(ctx context.Context, fn func(ctx context.Context, matchRepo repositories.MatchRepository, userRepo repositories.UserRepository) error) error <span class="cov0" title="0">{
        tx, err := r.pool.Begin(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback(ctx)

        dbQueries := r.queries.WithTx(tx)

        txMatchRepo := &amp;matchRepo{queries: dbQueries}
        txUserRepo := NewPlayerRepository(dbQueries, r.pool)
        if err := fn(ctx, txMatchRepo, txUserRepo); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return tx.Commit(ctx)</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package connection

import (
        "context"
        "database/sql"
        "errors"

        "github.com/MommusWinner/MicroDurak/internal/database"
        "github.com/MommusWinner/MicroDurak/internal/services/players/domain/models"
        "github.com/google/uuid"
        "github.com/jackc/pgx/v5/pgxpool"
)

type playerRepo struct {
        queries *database.Queries
        pool    *pgxpool.Pool
}

func NewPlayerRepository(queries *database.Queries, pool *pgxpool.Pool) *playerRepo <span class="cov0" title="0">{
        return &amp;playerRepo{queries: queries, pool: pool}
}</span>

func (r *playerRepo) Add(ctx context.Context, player *models.User) (uuid.UUID, error) <span class="cov0" title="0">{
        id, err := r.queries.CreatePlayer(ctx, database.CreatePlayerParams{Name: player.Name, Age: int16(player.Age)})
        return id, err
}</span>

func (r *playerRepo) UpdatePlayerRating(ctx context.Context, playerID uuid.UUID, newRating int) error <span class="cov0" title="0">{
        _, err := r.queries.UpdatePlayerRating(ctx, database.UpdatePlayerRatingParams{ID: playerID, Rating: int32(newRating)})
        return err
}</span>

func (r *playerRepo) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        panic("not implemented")</span>
}

func (r *playerRepo) GetById(ctx context.Context, id uuid.UUID) (*models.User, error) <span class="cov0" title="0">{
        user, err := r.queries.GetPlayerById(ctx, id)
        if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                return nil, nil
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">player := databasePlayerToDomain(user)
        return &amp;player, nil</span>
}

func (r *playerRepo) GetAll(ctx context.Context) ([]models.User, error) <span class="cov0" title="0">{
        players, err := r.queries.GetAllPlayers(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return databasePlayersToDomain(players), nil</span>
}

func databasePlayerToDomain(player database.Player) models.User <span class="cov0" title="0">{
        return models.User{
                Id:     player.ID,
                Name:   player.Name,
                Age:    int(player.Age),
                Rating: int(player.Rating),
        }
}</span>

func databasePlayersToDomain(players []database.Player) []models.User <span class="cov0" title="0">{
        users := make([]models.User, len(players))

        for i, player := range players </span><span class="cov0" title="0">{
                users[i] = databasePlayerToDomain(player)
        }</span>

        <span class="cov0" title="0">return users</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package core

import (
        "log/slog"
        "os"

        "github.com/MommusWinner/MicroDurak/internal/services/players/connection"
        "github.com/MommusWinner/MicroDurak/internal/services/players/domain"
        "github.com/MommusWinner/MicroDurak/internal/services/players/domain/infra"
        "github.com/MommusWinner/MicroDurak/internal/services/players/infra/config"
        "github.com/alecthomas/kong"
)

type Config struct {
        JWTPrivate  string `help:"Base64 Private key for the jwt"       env:"JWT_PRIVATE" required:"true"`
        PlayersURL  string `help:"URL pointing to the Players Service"  env:"PLAYERS_URL" required:"true"`
        Port        string `help:"Port to listen on"                    env:"PORT" default:"8080"`
        DatabaseURL string `help:"Database connection URL"              env:"DATABASE_URL" required:"true"`
        LogLevel    string `help:"Log level (debug, info, warn, error)" env:"LOG_LEVEL" default:"info"`
}

func Load() (*Config, error) <span class="cov0" title="0">{
        cfg := &amp;Config{}
        parser, err := kong.New(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Parse command-line flags, environment variables, and config file
        <span class="cov0" title="0">_, err = parser.Parse(nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return cfg, nil</span>
}

type Ctx struct {
        con    domain.Connection
        cfg    infra.Config
        logger *slog.Logger
}

func (c *Ctx) Config() infra.Config <span class="cov0" title="0">{
        return c.cfg
}</span>

func (c *Ctx) Logger() *slog.Logger <span class="cov0" title="0">{
        return c.logger
}</span>

func (c *Ctx) Connection() domain.Connection <span class="cov0" title="0">{
        return c.con
}</span>
func (c *Ctx) Make() domain.Context <span class="cov0" title="0">{
        return &amp;Ctx{
                con:    c.con,
                logger: c.logger,
                cfg:    c.cfg,
        }
}</span>

func InitCtx() *Ctx <span class="cov0" title="0">{
        cfg := config.Make()
        logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))

        db := connection.Make(cfg)

        return &amp;Ctx{
                cfg:    cfg,
                logger: logger,
                con:    db,
        }
}</span>

func DisposeCtx(ctx *Ctx) <span class="cov0" title="0">{
        connection.Close(ctx.con)
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package core

import (
        "github.com/MommusWinner/MicroDurak/internal/services/players/delivery/http"
        "github.com/MommusWinner/MicroDurak/internal/services/players/domain"
        "github.com/MommusWinner/MicroDurak/internal/services/players/domain/cases"
)

type Di struct {
        Ctx           domain.Context
        PlayerUseCase *cases.PlayerUseCase
        MatchUseCase  *cases.MatchUseCase
        PlayerHandler *http.PlayerHandler
}

func NewDi() *Di <span class="cov0" title="0">{
        ctx := InitCtx()

        var (
                playerUseCase = cases.NewPlayersUseCase(ctx)
                matchUseCase  = cases.NewMatchUseCase(ctx)
                playerHandler = http.NewPlayerHandler(ctx, playerUseCase, matchUseCase)
        )

        return &amp;Di{
                Ctx:           ctx,
                PlayerUseCase: playerUseCase,
                MatchUseCase:  matchUseCase,
                PlayerHandler: playerHandler,
        }
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package core

import (
        "net"

        pb "github.com/MommusWinner/MicroDurak/internal/contracts/players/v1"
        grpc2 "github.com/MommusWinner/MicroDurak/internal/services/players/delivery/grpc"
        "github.com/MommusWinner/MicroDurak/internal/services/players/domain"
        "github.com/MommusWinner/MicroDurak/internal/services/players/domain/cases"
        "google.golang.org/grpc"
)

type GrpcServer struct {
        listener   net.Listener
        grpcServer *grpc.Server
}

func NewGrpcServer(ctx domain.Context, playerUseCase *cases.PlayerUseCase, matchUseCase *cases.MatchUseCase) *GrpcServer <span class="cov0" title="0">{
        grpcListener, err := net.Listen("tcp", ":"+ctx.Config().GetGRPCPort())
        if err != nil </span><span class="cov0" title="0">{
                panic("failed to listen: " + err.Error())</span>
        }

        <span class="cov0" title="0">var opts []grpc.ServerOption
        grpcServer := grpc.NewServer(opts...)

        service := grpc2.NewPlayerService(ctx, playerUseCase, matchUseCase)
        pb.RegisterPlayersServer(grpcServer, service)

        return &amp;GrpcServer{
                listener:   grpcListener,
                grpcServer: grpcServer,
        }</span>
}

func (s *GrpcServer) Start() <span class="cov0" title="0">{
        if err := s.grpcServer.Serve(s.listener); err != nil </span><span class="cov0" title="0">{
                panic("failed to serve: " + err.Error())</span>
        }
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package core

import (
        "github.com/MommusWinner/MicroDurak/internal/services/players/delivery/http"
        "github.com/MommusWinner/MicroDurak/internal/services/players/domain"
        "github.com/MommusWinner/MicroDurak/lib/validate"
        "github.com/go-playground/validator"
        "github.com/labstack/echo/v4"
        "github.com/swaggo/echo-swagger"
)

type HttpServer struct {
        app *echo.Echo
        ctx domain.Context
}

type Server interface {
        Start()
        App() *echo.Echo
}

func NewHttpServer(ctx domain.Context, playerHandler *http.PlayerHandler) Server <span class="cov0" title="0">{
        app := echo.New()
        app.Validator = validate.NewHttpValidator(validator.New())

        app.GET("/swagger/*", echoSwagger.WrapHandler)

        http.AddRoutes(app, playerHandler)

        return &amp;HttpServer{
                app: app,
                ctx: ctx,
        }
}</span>

func (s *HttpServer) Start() <span class="cov0" title="0">{
        err := s.app.Start(":" + s.ctx.Config().GetHTTPPort())
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                panic("http server inst start successfully")</span>
        }
}

func (s *HttpServer) App() *echo.Echo <span class="cov0" title="0">{
        return s.app
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package grpc

import (
        "context"
        "errors"
        "fmt"

        "github.com/MommusWinner/MicroDurak/internal/contracts/players/v1"
        "github.com/MommusWinner/MicroDurak/internal/services/players/domain"
        "github.com/MommusWinner/MicroDurak/internal/services/players/domain/cases"
        "github.com/MommusWinner/MicroDurak/internal/services/players/domain/models"
        "github.com/MommusWinner/MicroDurak/internal/services/players/domain/props"
        "github.com/google/uuid"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

type PlayerService struct {
        players.UnimplementedPlayersServer
        ctx           domain.Context
        playerUseCase *cases.PlayerUseCase
        matchUseCase  *cases.MatchUseCase
}

func NewPlayerService(ctx domain.Context, playerUseCase *cases.PlayerUseCase, matchUseCase *cases.MatchUseCase) *PlayerService <span class="cov0" title="0">{
        return &amp;PlayerService{ctx: ctx, playerUseCase: playerUseCase, matchUseCase: matchUseCase}
}</span>

func (ps *PlayerService) CreatePlayer(ctx context.Context, req *players.CreatePlayerRequest) (*players.CreatePlayerReply, error) <span class="cov0" title="0">{
        resp, err := ps.playerUseCase.Create(props.CreatePlayerReq{Name: req.Name, Age: int(req.Age)})

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;players.CreatePlayerReply{Id: resp.Id.String()}, nil</span>
}

func (ps *PlayerService) GetPlayer(ctx context.Context, req *players.GetPlayerRequest) (*players.Player, error) <span class="cov0" title="0">{
        playerId, err := uuid.Parse(req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.New(codes.InvalidArgument, "player_id is not uuid").Err()
        }</span>

        <span class="cov0" title="0">resp, err := ps.playerUseCase.GetById(props.GetPlayerByIdReq{Id: playerId})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.Player == nil </span><span class="cov0" title="0">{
                err = status.New(codes.NotFound, fmt.Sprintf("Couldn't find player by id: %s", req.Id)).Err()
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;players.Player{
                Id:     resp.Player.Id.String(),
                Name:   resp.Player.Name,
                Age:    int32(resp.Player.Age),
                Rating: int32(resp.Player.Rating),
        }, nil</span>
}

func grpcGameResultToDomain(gr players.GameResult) models.GameResult <span class="cov0" title="0">{
        switch gr </span>{
        case players.GameResult_DRAW:<span class="cov0" title="0">
                return models.GameResult_DRAW</span>
        case players.GameResult_WIN:<span class="cov0" title="0">
                return models.GameResult_WIN</span>
        case players.GameResult_INTERRUPTED:<span class="cov0" title="0">
                return models.GameResult_INTERRUPTED</span>
        default:<span class="cov0" title="0">
                panic("unknown game result")</span>
        }
}

func (ps *PlayerService) CreateMatchResult(ctx context.Context, req *players.CreateMatchResultRequest) (*players.CreateMatchResultResponse, error) <span class="cov0" title="0">{
        gameResult := grpcGameResultToDomain(req.GameResult)

        playerPlacements := make([]models.PlayerPlacement, len(req.PlayerPlacements))
        for i, placement := range req.PlayerPlacements </span><span class="cov0" title="0">{
                playerPlacements[i] = models.PlayerPlacement{Id: placement.PlayerId, Place: int(placement.PlayerPlace)}
        }</span>

        <span class="cov0" title="0">reqArgs := props.CreateMatchResutlReq{GameResult: gameResult, PlayerPlacements: playerPlacements}
        resp, err := ps.matchUseCase.CreateMatchResult(ctx, &amp;reqArgs)
        if errors.Is(err, cases.ErrNoPlayers) </span><span class="cov0" title="0">{
                return nil, status.New(codes.InvalidArgument, "No players").Err()
        }</span>

        <span class="cov0" title="0">playerRatings := make([]*players.PlayerPlacementResponse, len(resp.PlayerMatchResults))
        for i, rating := range resp.PlayerMatchResults </span><span class="cov0" title="0">{
                playerRatings[i] = &amp;players.PlayerPlacementResponse{
                        PlayerId:           rating.Id.String(),
                        PlayerRating:       rating.Rating,
                        PlayerRatingChange: rating.RatingChange,
                }
        }</span>

        <span class="cov0" title="0">response := &amp;players.CreateMatchResultResponse{
                MatchResultId: resp.MatchId.String(),
                PlayerRatings: playerRatings,
        }

        return response, nil</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/matches": {
            "get": {
                "description": "Returns a list of all match results in the system",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "matches"
                ],
                "summary": "Get all match results",
                "responses": {
                    "200": {
                        "description": "List of match results",
                        "schema": {
                            "$ref": "#/definitions/github_com_MommusWinner_MicroDurak_internal_services_players_domain_props.GetAllMatchResultsResp"
                        }
                    },
                    "500": {
                        "description": "Internal server error"
                    }
                }
            },
            "post": {
                "description": "Creates a match result with player placements and updates player ratings based on the game outcome",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "matches"
                ],
                "summary": "Create match result",
                "parameters": [
                    {
                        "description": "Match result data",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/delivery_http.CreateMatchRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Match result created successfully",
                        "schema": {
                            "$ref": "#/definitions/delivery_http.CreateMatchResponse"
                        }
                    },
                    "400": {
                        "description": "Bad request - validation error"
                    },
                    "500": {
                        "description": "Internal server error"
                    }
                }
            }
        },
        "/matches/{id}": {
            "get": {
                "description": "Returns match result information by its unique identifier",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "matches"
                ],
                "summary": "Get match result by ID",
                "parameters": [
                    {
                        "type": "string",
                        "format": "uuid",
                        "description": "Match UUID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Match result information",
                        "schema": {
                            "$ref": "#/definitions/github_com_MommusWinner_MicroDurak_internal_services_players_domain_models.MatchDetails"
                        }
                    },
                    "400": {
                        "description": "Invalid ID format"
                    },
                    "404": {
                        "description": "Match not found"
                    },
                    "500": {
                        "description": "Internal server error"
                    }
                }
            }
        },
        "/players": {
            "get": {
                "description": "Returns a list of all players in the system",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "players"
                ],
                "summary": "Get all players",
                "responses": {
                    "200": {
                        "description": "List of players",
                        "schema": {
                            "$ref": "#/definitions/delivery_http.PlayersResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error"
                    }
                }
            }
        },
        "/players/{id}": {
            "get": {
                "description": "Returns player information by their unique identifier",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "players"
                ],
                "summary": "Get player by ID",
                "parameters": [
                    {
                        "type": "string",
                        "format": "uuid",
                        "description": "Player UUID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Player information",
                        "schema": {
                            "$ref": "#/definitions/delivery_http.PlayerResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid ID format"
                    },
                    "404": {
                        "description": "Player not found"
                    },
                    "500": {
                        "description": "Internal server error"
                    }
                }
            }
        }
    },
    "definitions": {
        "delivery_http.CreateMatchRequest": {
            "type": "object",
            "properties": {
                "game_result": {
                    "type": "string"
                },
                "player_placements": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/delivery_http.PlayerPlacementReq"
                    }
                }
            }
        },
        "delivery_http.CreateMatchResponse": {
            "type": "object",
            "properties": {
                "match_id": {
                    "type": "string"
                },
                "player_match_results": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/delivery_http.PlayerMatchResultResponse"
                    }
                }
            }
        },
        "delivery_http.PlayerMatchResultResponse": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "string"
                },
                "rating": {
                    "type": "integer"
                },
                "rating_change": {
                    "type": "integer"
                }
            }
        },
        "delivery_http.PlayerPlacementReq": {
            "type": "object",
            "required": [
                "player_id",
                "player_place"
            ],
            "properties": {
                "player_id": {
                    "type": "string"
                },
                "player_place": {
                    "type": "integer",
                    "minimum": 1
                }
            }
        },
        "delivery_http.PlayerResponse": {
            "type": "object",
            "properties": {
                "age": {
                    "type": "integer"
                },
                "id": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "rating": {
                    "type": "integer"
                }
            }
        },
        "delivery_http.PlayersResponse": {
            "type": "object",
            "properties": {
                "players": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/delivery_http.PlayerResponse"
                    }
                }
            }
        },
        "github_com_MommusWinner_MicroDurak_internal_services_players_domain_models.MatchDetails": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "string"
                },
                "players": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/github_com_MommusWinner_MicroDurak_internal_services_players_domain_models.PlayerMatchResultDetails"
                    }
                },
                "result": {
                    "type": "string"
                }
            }
        },
        "github_com_MommusWinner_MicroDurak_internal_services_players_domain_models.PlayerMatchResultDetails": {
            "type": "object",
            "properties": {
                "current_rating": {
                    "type": "integer"
                },
                "place": {
                    "type": "integer"
                },
                "player_id": {
                    "type": "string"
                },
                "player_name": {
                    "type": "string"
                },
                "rating_changed": {
                    "type": "integer"
                }
            }
        },
        "github_com_MommusWinner_MicroDurak_internal_services_players_domain_props.GetAllMatchResultsResp": {
            "type": "object",
            "properties": {
                "matches": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/github_com_MommusWinner_MicroDurak_internal_services_players_domain_models.MatchDetails"
                    }
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "localhost:8090",
        BasePath:         "/api/v1",
        Schemes:          []string{},
        Title:            "Player Service API",
        Description:      "API for working with players",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">package http

import (
        "context"
        "errors"
        "net/http"

        "github.com/MommusWinner/MicroDurak/internal/services/players/domain"
        "github.com/MommusWinner/MicroDurak/internal/services/players/domain/cases"
        "github.com/MommusWinner/MicroDurak/internal/services/players/domain/models"
        "github.com/MommusWinner/MicroDurak/internal/services/players/domain/props"
        "github.com/google/uuid"
        "github.com/labstack/echo/v4"
)

type PlayerHandler struct {
        ctx           domain.Context
        playerUseCase *cases.PlayerUseCase
        matchUseCase  *cases.MatchUseCase
}

func NewPlayerHandler(ctx domain.Context, playerUseCase *cases.PlayerUseCase, matchUseCase *cases.MatchUseCase) *PlayerHandler <span class="cov0" title="0">{
        return &amp;PlayerHandler{
                ctx:           ctx,
                playerUseCase: playerUseCase,
                matchUseCase:  matchUseCase,
        }
}</span>

type PlayerResponse struct {
        Id     string `json:"id"`
        Name   string `json:"name"`
        Age    int    `json:"age"`
        Rating int    `json:"rating"`
}

type PlayersResponse struct {
        Players []PlayerResponse `json:"players"`
}

type CreateMatchRequest struct {
        GameResult       string               `json:"game_result"`
        PlayerPlacements []PlayerPlacementReq `json:"player_placements"`
}

type PlayerPlacementReq struct {
        PlayerId    string `json:"player_id" validate:"required,uuid"`
        PlayerPlace int    `json:"player_place" validate:"required,min=1"`
}

type PlayerMatchResultResponse struct {
        Id           string `json:"id"`
        Rating       int32  `json:"rating"`
        RatingChange int32  `json:"rating_change"`
}

type CreateMatchResponse struct {
        MatchId            string                      `json:"match_id"`
        PlayerMatchResults []PlayerMatchResultResponse `json:"player_match_results"`
}

var internalServerError = echo.NewHTTPError(http.StatusInternalServerError, "Internal Server Error")

// GetAll retrieves a list of all players
// @Summary Get all players
// @Description Returns a list of all players in the system
// @Tags players
// @Accept json
// @Produce json
// @Success 200 {object} PlayersResponse "List of players"
// @Failure 500 "Internal server error"
// @Router /players [get]
func (h *PlayerHandler) GetAll(c echo.Context) error <span class="cov0" title="0">{
        resp, err := h.playerUseCase.GetAll(props.GetAllPlayersReq{})

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, cases.ErrNoPlayers) </span><span class="cov0" title="0">{
                        return c.JSON(http.StatusOK, PlayersResponse{Players: []PlayerResponse{}})
                }</span>
                <span class="cov0" title="0">return internalServerError</span>
        }

        <span class="cov0" title="0">players := make([]PlayerResponse, 0, len(resp.Players))
        for _, p := range resp.Players </span><span class="cov0" title="0">{
                players = append(players, PlayerResponse{
                        Id:     p.Id.String(),
                        Name:   p.Name,
                        Age:    p.Age,
                        Rating: p.Rating,
                })
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, PlayersResponse{Players: players})</span>
}

// GetById retrieves a player by ID
// @Summary Get player by ID
// @Description Returns player information by their unique identifier
// @Tags players
// @Accept json
// @Produce json
// @Param id path string true "Player UUID" format(uuid)
// @Success 200 {object} PlayerResponse "Player information"
// @Failure 400 "Invalid ID format"
// @Failure 404 "Player not found"
// @Failure 500 "Internal server error"
// @Router /players/{id} [get]
func (h *PlayerHandler) GetById(c echo.Context) error <span class="cov0" title="0">{
        idParam := c.Param("id")
        playerId, err := uuid.Parse(idParam)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "Invalid player ID format")
        }</span>

        <span class="cov0" title="0">resp, err := h.playerUseCase.GetById(props.GetPlayerByIdReq{Id: playerId})

        if err != nil </span><span class="cov0" title="0">{
                return internalServerError
        }</span>

        <span class="cov0" title="0">if resp.Player == nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusNotFound, "Player not found")
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, PlayerResponse{
                Id:     resp.Player.Id.String(),
                Name:   resp.Player.Name,
                Age:    resp.Player.Age,
                Rating: resp.Player.Rating,
        })</span>
}

// CreateMatch creates a match result and updates player ratings
// @Summary Create match result
// @Description Creates a match result with player placements and updates player ratings based on the game outcome
// @Tags matches
// @Accept json
// @Produce json
// @Param request body CreateMatchRequest true "Match result data"
// @Success 201 {object} CreateMatchResponse "Match result created successfully"
// @Failure 400 "Bad request - validation error"
// @Failure 500 "Internal server error"
// @Router /matches [post]
func (h *PlayerHandler) CreateMatch(c echo.Context) error <span class="cov0" title="0">{
        req := new(CreateMatchRequest)

        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "Invalid request body")
        }</span>
        <span class="cov0" title="0">if err := c.Validate(req); err != nil </span><span class="cov0" title="0">{
                h.ctx.Logger().Info("Hello")
                h.ctx.Logger().Info(err.Error())
                return err
        }</span>

        <span class="cov0" title="0">var gameResult models.GameResult
        switch req.GameResult </span>{
        case "win":<span class="cov0" title="0">
                gameResult = models.GameResult_WIN</span>
        case "draw":<span class="cov0" title="0">
                gameResult = models.GameResult_DRAW</span>
        case "interrupted":<span class="cov0" title="0">
                gameResult = models.GameResult_INTERRUPTED</span>
        default:<span class="cov0" title="0">
                return echo.NewHTTPError(http.StatusBadRequest, "Invalid game_result value. Must be win, draw, or interrupted")</span>
        }

        <span class="cov0" title="0">playerPlacements := make([]models.PlayerPlacement, len(req.PlayerPlacements))
        for i, placement := range req.PlayerPlacements </span><span class="cov0" title="0">{
                playerPlacements[i] = models.PlayerPlacement{
                        Id:    placement.PlayerId,
                        Place: placement.PlayerPlace,
                }
        }</span>

        <span class="cov0" title="0">matchReq := &amp;props.CreateMatchResutlReq{
                GameResult:       gameResult,
                PlayerPlacements: playerPlacements,
        }

        resp, err := h.matchUseCase.CreateMatchResult(context.Background(), matchReq)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, cases.ErrNoPlayers) </span><span class="cov0" title="0">{
                        return echo.NewHTTPError(http.StatusBadRequest, "No players provided")
                }</span>
                <span class="cov0" title="0">if errors.Is(err, cases.ErrUnprocessableId) </span><span class="cov0" title="0">{
                        return echo.NewHTTPError(http.StatusBadRequest, "Unprocessable player id")
                }</span>
                <span class="cov0" title="0">if errors.Is(err, cases.ErrPlayerNotFound) </span><span class="cov0" title="0">{
                        return echo.NewHTTPError(http.StatusNotFound, "Couldn't find the player")
                }</span>
                <span class="cov0" title="0">return internalServerError</span>
        }

        <span class="cov0" title="0">playerResults := make([]PlayerMatchResultResponse, len(resp.PlayerMatchResults))
        for i, result := range resp.PlayerMatchResults </span><span class="cov0" title="0">{
                playerResults[i] = PlayerMatchResultResponse{
                        Id:           result.Id.String(),
                        Rating:       result.Rating,
                        RatingChange: result.RatingChange,
                }
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusCreated, CreateMatchResponse{
                MatchId:            resp.MatchId.String(),
                PlayerMatchResults: playerResults,
        })</span>
}

// GetMatchResultById retrieves a match result by ID
// @Summary Get match result by ID
// @Description Returns match result information by its unique identifier
// @Tags matches
// @Accept json
// @Produce json
// @Param id path string true "Match UUID" format(uuid)
// @Success 200 {object} models.MatchDetails "Match result information"
// @Failure 400 "Invalid ID format"
// @Failure 404 "Match not found"
// @Failure 500 "Internal server error"
// @Router /matches/{id} [get]
func (h *PlayerHandler) GetMatchResultById(c echo.Context) error <span class="cov0" title="0">{
        idParam := c.Param("id")
        matchId, err := uuid.Parse(idParam)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "Invalid match ID format")
        }</span>

        <span class="cov0" title="0">resp, err := h.matchUseCase.GetMatchResultById(context.Background(), &amp;props.GetMatchResultByIdReq{Id: matchId})
        if err != nil </span><span class="cov0" title="0">{
                return internalServerError
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, resp.Match)</span>
}

// GetAllMatchResults retrieves all match results
// @Summary Get all match results
// @Description Returns a list of all match results in the system
// @Tags matches
// @Accept json
// @Produce json
// @Success 200 {object} props.GetAllMatchResultsResp "List of match results"
// @Failure 500 "Internal server error"
// @Router /matches [get]
func (h *PlayerHandler) GetAllMatchResults(c echo.Context) error <span class="cov0" title="0">{
        resp, err := h.matchUseCase.GetAllMatchResults(context.Background(), &amp;props.GetAllMatchResultsReq{})
        if err != nil </span><span class="cov0" title="0">{
                return internalServerError
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, resp)</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package http

import (
        "github.com/labstack/echo/v4"
        echoSwagger "github.com/swaggo/echo-swagger"
)

func AddRoutes(e *echo.Echo, playerHandler *PlayerHandler) <span class="cov0" title="0">{
        e.GET("/swagger/*", echoSwagger.WrapHandler)

        e.GET("/api/v1/players", playerHandler.GetAll)
        e.GET("/api/v1/players/:id", playerHandler.GetById)
        e.POST("/api/v1/matches", playerHandler.CreateMatch)
        e.GET("/api/v1/matches/:id", playerHandler.GetMatchResultById)
        e.GET("/api/v1/matches", playerHandler.GetAllMatchResults)
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">package cases

import (
        "context"
        "fmt"

        "github.com/MommusWinner/MicroDurak/internal/services/players/domain"
        "github.com/MommusWinner/MicroDurak/internal/services/players/domain/models"
        "github.com/MommusWinner/MicroDurak/internal/services/players/domain/props"
        "github.com/MommusWinner/MicroDurak/internal/services/players/domain/repositories"
        "github.com/MommusWinner/MicroDurak/internal/services/players/rating"
        "github.com/google/uuid"
)

type MatchUseCase struct {
        ctx domain.Context
}

func NewMatchUseCase(ctx domain.Context) *MatchUseCase <span class="cov0" title="0">{
        return &amp;MatchUseCase{
                ctx: ctx,
        }
}</span>

func (uc *MatchUseCase) CreateMatchResult(ctx context.Context, req *props.CreateMatchResutlReq) (resp *props.CreateMatchResutlResp, err error) <span class="cov0" title="0">{
        if len(req.PlayerPlacements) == 0 </span><span class="cov0" title="0">{
                err = ErrNoPlayers
                uc.ctx.Logger().Error(err.Error())
        }</span>

        <span class="cov0" title="0">playerStats := make([]models.PlayerStats, len(req.PlayerPlacements))

        for i, placement := range req.PlayerPlacements </span><span class="cov0" title="0">{
                id, err := uuid.Parse(placement.Id)
                if err != nil </span><span class="cov0" title="0">{
                        uc.ctx.Logger().Error("Unprocessable player id", "player_id", placement.Id)
                        return nil, ErrUnprocessableId
                }</span>
                <span class="cov0" title="0">user, err := uc.ctx.Connection().UserRepository().GetById(ctx, id)
                if err != nil </span><span class="cov0" title="0">{
                        uc.ctx.Logger().Error(err.Error())
                        return nil, ErrInternal
                }</span>
                <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                        uc.ctx.Logger().Error("Couldn't find player by id", "player_id", placement.Id)
                        return nil, ErrPlayerNotFound
                }</span>
                <span class="cov0" title="0">playerStats[i] = models.PlayerStats{
                        Id:     id,
                        Place:  placement.Place,
                        Rating: user.Rating,
                }</span>
        }

        <span class="cov0" title="0">playerRatings := make([]models.PlayerMatchResult, len(req.PlayerPlacements))

        err = uc.ctx.Connection().MatchRepository().WithTransaction(ctx,
                func(ctx context.Context, matchRepo repositories.MatchRepository, userRepo repositories.UserRepository) error </span><span class="cov0" title="0">{
                        match, err := matchRepo.Add(ctx, len(req.PlayerPlacements), req.GameResult)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("Failed to create match: %w", err)
                        }</span>

                        <span class="cov0" title="0">playerScores, err := rating.CalculatePlayerScores(playerStats)

                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("Failed to calculate ratings: %w", err)
                        }</span>

                        <span class="cov0" title="0">for i, player := range playerScores </span><span class="cov0" title="0">{
                                if err := matchRepo.AddPlayerToMatch(ctx, match.Id, player.Id, player.Place, int32(player.RatingChange)); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("Failed to add player to match: %w", err)
                                }</span>

                                <span class="cov0" title="0">if err := userRepo.UpdatePlayerRating(ctx, player.Id, player.NewRating); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("Failed to update player rating: %w", err)
                                }</span>

                                <span class="cov0" title="0">playerRatings[i] = models.PlayerMatchResult{
                                        Id:           player.Id,
                                        Rating:       int32(player.NewRating),
                                        RatingChange: int32(player.RatingChange),
                                }</span>
                        }

                        <span class="cov0" title="0">resp = &amp;props.CreateMatchResutlResp{
                                MatchId:            match.Id,
                                PlayerMatchResults: playerRatings,
                        }

                        return nil</span>
                })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Match creation failed: %w", err)
        }</span>

        <span class="cov0" title="0">return</span>
}

func (uc *MatchUseCase) GetMatchResultById(ctx context.Context, req *props.GetMatchResultByIdReq) (resp *props.GetMatchResultByIdResp, err error) <span class="cov0" title="0">{
        match, err := uc.ctx.Connection().MatchRepository().GetById(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                uc.ctx.Logger().Error(err.Error())
                return nil, ErrInternal
        }</span>

        <span class="cov0" title="0">placements, err := uc.ctx.Connection().MatchRepository().GetPlayerPlacementsByMatchId(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                uc.ctx.Logger().Error(err.Error())
                return nil, ErrInternal
        }</span>

        <span class="cov0" title="0">resp = &amp;props.GetMatchResultByIdResp{}
        resp.Match.Id = match.Id
        resp.Match.Result = models.GameResult_name[int32(match.GameResult)]

        for _, placement := range placements </span><span class="cov0" title="0">{
                playerDetail := models.PlayerMatchResultDetails{
                        PlayerId:      placement.PlayerId,
                        PlayerName:    placement.PlayerName,
                        RatingChanged: placement.RatingChange,
                        Place:         placement.PlayerPlace,
                        CurrentRating: placement.CurrentRating,
                }
                resp.Match.Players = append(resp.Match.Players, playerDetail)
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}

func (uc *MatchUseCase) GetAllMatchResults(ctx context.Context, req *props.GetAllMatchResultsReq) (resp *props.GetAllMatchResultsResp, err error) <span class="cov0" title="0">{
        matches, err := uc.ctx.Connection().MatchRepository().GetAll(ctx)
        if err != nil </span><span class="cov0" title="0">{
                uc.ctx.Logger().Error(err.Error())
                return nil, ErrInternal
        }</span>

        <span class="cov0" title="0">resp = &amp;props.GetAllMatchResultsResp{}
        resp.Matches = make([]models.MatchDetails, len(matches))

        for i, match := range matches </span><span class="cov0" title="0">{
                resp.Matches[i].Id = match.Id
                resp.Matches[i].Result = models.GameResult_name[int32(match.GameResult)]

                placements, err := uc.ctx.Connection().MatchRepository().GetPlayerPlacementsByMatchId(ctx, match.Id)
                if err != nil </span><span class="cov0" title="0">{
                        uc.ctx.Logger().Error(err.Error())
                        continue</span>
                }

                <span class="cov0" title="0">for _, placement := range placements </span><span class="cov0" title="0">{
                        playerDetail := models.PlayerMatchResultDetails{
                                PlayerId:      placement.PlayerId,
                                PlayerName:    placement.PlayerName,
                                RatingChanged: placement.RatingChange,
                                Place:         placement.PlayerPlace,
                                CurrentRating: placement.CurrentRating,
                        }
                        resp.Matches[i].Players = append(resp.Matches[i].Players, playerDetail)
                }</span>
        }

        <span class="cov0" title="0">return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package cases

import (
        "context"

        "github.com/MommusWinner/MicroDurak/internal/services/players/domain"
        "github.com/MommusWinner/MicroDurak/internal/services/players/domain/models"
        "github.com/MommusWinner/MicroDurak/internal/services/players/domain/props"
)

type PlayerUseCase struct {
        ctx domain.Context
}

func NewPlayersUseCase(ctx domain.Context) *PlayerUseCase <span class="cov0" title="0">{
        return &amp;PlayerUseCase{
                ctx: ctx,
        }
}</span>

func (uc *PlayerUseCase) Create(args props.CreatePlayerReq) (resp props.CreatePlayerResp, err error) <span class="cov0" title="0">{
        id, err := uc.ctx.Connection().UserRepository().Add(context.Background(), &amp;models.User{Name: args.Name, Age: args.Age})
        if err != nil </span><span class="cov0" title="0">{
                uc.ctx.Logger().Error(err.Error())
                err = ErrInternal
                return
        }</span>

        <span class="cov0" title="0">resp = props.CreatePlayerResp{
                Id: id,
        }
        return</span>
}

func (uc *PlayerUseCase) GetById(args props.GetPlayerByIdReq) (resp props.GetPlayerByIdResp, err error) <span class="cov0" title="0">{
        user, err := uc.ctx.Connection().UserRepository().GetById(context.Background(), args.Id)
        if err != nil </span><span class="cov0" title="0">{

                uc.ctx.Logger().Error(err.Error())
                err = ErrInternal
                return
        }</span>

        <span class="cov0" title="0">resp = props.GetPlayerByIdResp{
                Player: user,
        }
        return</span>
}

func (uc *PlayerUseCase) GetAll(args props.GetAllPlayersReq) (resp props.GetAllPlayersResp, err error) <span class="cov0" title="0">{
        players, err := uc.ctx.Connection().UserRepository().GetAll(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                uc.ctx.Logger().Error(err.Error())
                err = ErrInternal
                return
        }</span>

        <span class="cov0" title="0">resp = props.GetAllPlayersResp{
                Players: players,
        }
        return</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package config

import (
        "github.com/alecthomas/kong"
        "log"
)

import ()

type Config struct {
        JWTPublic   string `help:"Base64 Private key for the jwt" env:"JWT_PUBLIC" required:"true"`
        HTTPPort    string `help:"Port to listen on" env:"HTTP_PORT" default:"8080"`
        GRPCPort    string `help:"Port to listen on" env:"GRPC_PORT" default:"9090"`
        DatabaseURL string `help:"Database connection URL" env:"DATABASE_URL" required:"true"`
        LogLevel    string `help:"Log level (debug, info, warn, error)" env:"LOG_LEVEL" default:"info"`
}

func Make() *Config <span class="cov0" title="0">{
        cfg := &amp;Config{}
        parser, err := kong.New(cfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Panic(err)
        }</span>

        // Parse command-line flags, environment variables, and config file
        <span class="cov0" title="0">_, err = parser.Parse(nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Panic(err)
        }</span>
        <span class="cov0" title="0">return cfg</span>
}

func (s *Config) GetJwtPublic() string <span class="cov0" title="0">{
        return s.JWTPublic
}</span>

func (s *Config) GetHTTPPort() string <span class="cov0" title="0">{
        return s.HTTPPort
}</span>

func (s *Config) GetGRPCPort() string <span class="cov0" title="0">{
        return s.GRPCPort
}</span>
func (s *Config) GetDatabaseURL() string <span class="cov0" title="0">{
        return s.DatabaseURL
}</span>

func (s *Config) GetLogLevel() string <span class="cov0" title="0">{
        return s.LogLevel
}</span>
</pre>
		
		<pre class="file" id="file68" style="display: none">package rating

import (
        "errors"
        "math"

        "github.com/MommusWinner/MicroDurak/internal/services/players/domain/models"
)

const kCoeff float64 = 30
const dCoeff float64 = 400

func CalculatePlayerScores(players []models.PlayerStats) ([]models.PlayerScore, error) <span class="cov5" title="4">{
        playerCount := len(players)
        if playerCount &lt; 2 </span><span class="cov1" title="1">{
                return nil, errors.New("at least 2 players required")
        }</span>

        <span class="cov4" title="3">playerScores := make([]models.PlayerScore, playerCount)
        var gamesCount float64 = float64(playerCount) * (float64(playerCount) - 1) / 2

        for i, playerStats := range players </span><span class="cov7" title="8">{
                var eTop float64 = 0
                for j, otherPlayerStats := range players </span><span class="cov10" title="22">{
                        if i == j </span><span class="cov7" title="8">{
                                continue</span>
                        }
                        <span class="cov8" title="14">rDiff := float64(otherPlayerStats.Rating - playerStats.Rating)
                        eTop += 1 / (1 + math.Pow(10, rDiff/dCoeff))</span>
                }

                <span class="cov7" title="8">e := eTop / gamesCount
                s := float64(playerCount-playerStats.Place) / gamesCount

                ratingDelta := kCoeff * (s - e)
                newRating := playerStats.Rating + int(math.Floor(ratingDelta))
                playerScores[i] = models.PlayerScore{Id: playerStats.Id, Place: playerStats.Place, NewRating: newRating, RatingChange: int(math.Floor(ratingDelta))}</span>
        }

        <span class="cov4" title="3">return playerScores, nil</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package amqppool

import (
        amqp "github.com/rabbitmq/amqp091-go"
        "log"
        "sync"
)

type ChannelPool struct {
        conn     *amqp.Connection
        mu       sync.Mutex
        free     []*amqp.Channel
        maxConns int
}

func NewChannelPool(conn *amqp.Connection, maxConns int) *ChannelPool <span class="cov0" title="0">{
        if maxConns &lt; 1 || maxConns &gt; 100 </span><span class="cov0" title="0">{
                panic("Channel pool size should be in range from 1 to 100")</span>
        }

        <span class="cov0" title="0">pool := &amp;ChannelPool{conn: conn, maxConns: maxConns}

        for range maxConns </span><span class="cov0" title="0">{
                ch, err := conn.Channel()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to create channel: %v", err)
                        continue</span>
                }
                <span class="cov0" title="0">pool.free = append(pool.free, ch)</span>
        }
        <span class="cov0" title="0">return pool</span>
}

func (p *ChannelPool) Get() (*amqp.Channel, error) <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()

        if len(p.free) &gt; 0 </span><span class="cov0" title="0">{
                ch := p.free[0]
                p.free = p.free[1:]
                return ch, nil
        }</span>

        <span class="cov0" title="0">return p.conn.Channel()</span>
}

func (p *ChannelPool) Return(ch *amqp.Channel) <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()

        if len(p.free) &lt; p.maxConns </span><span class="cov0" title="0">{
                p.free = append(p.free, ch)
        }</span> else<span class="cov0" title="0"> {
                ch.Close()
        }</span>
}

func (p *ChannelPool) Close() <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()

        for _, ch := range p.free </span><span class="cov0" title="0">{
                ch.Close()
        }</span>
        <span class="cov0" title="0">p.free = nil</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package jwt

import (
        "encoding/base64"
        "fmt"

        "github.com/golang-jwt/jwt/v5"
)

func VerifyToken(pubKeyEncoded string, tokenString string) (jwt.Claims, error) <span class="cov0" title="0">{
        pemBytes, err := base64.StdEncoding.DecodeString(pubKeyEncoded)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">publicKey, err := jwt.ParseRSAPublicKeyFromPEM(pemBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">token, err := jwt.Parse(tokenString, func(t *jwt.Token) (any, error) </span><span class="cov0" title="0">{
                if _, ok := t.Method.(*jwt.SigningMethodRSA); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", t.Header["alg"])
                }</span>
                <span class="cov0" title="0">return publicKey, nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return token.Claims, nil</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package jwt

import (
        "net/http"

        "github.com/labstack/echo/v4"
)

func AuthMiddleware(jwtKey string) echo.MiddlewareFunc <span class="cov0" title="0">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                return func(c echo.Context) error </span><span class="cov0" title="0">{
                        token := c.Request().Header.Get("Authorization")
                        if token == "" </span><span class="cov0" title="0">{
                                return echo.NewHTTPError(http.StatusUnauthorized, "missing token")
                        }</span>

                        <span class="cov0" title="0">claims, err := VerifyToken(jwtKey, token)
                        if err != nil </span><span class="cov0" title="0">{
                                return echo.NewHTTPError(http.StatusUnauthorized, "invalid token")
                        }</span>

                        <span class="cov0" title="0">playerId, err := claims.GetSubject()
                        if err != nil </span><span class="cov0" title="0">{
                                return echo.NewHTTPError(http.StatusUnauthorized, "invalid claims")
                        }</span>

                        <span class="cov0" title="0">c.Set("playerId", playerId)
                        return next(c)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package smtp

import (
        "bytes"
        "crypto/tls"
        "github.com/k3a/html2text"
        "gopkg.in/gomail.v2"
        "html/template"
)

type EmailData struct {
        Name    string
        Subject string
}

type SMTP struct {
        EmailFrom   string
        User        string
        Pass        string
        Host        string
        Port        int
        TemplateDir string
}

func (s *SMTP) SendEmailWithTemplate(email string, data *EmailData, tmpl *template.Template, emailTemp string) error <span class="cov0" title="0">{
        from := s.EmailFrom
        smtpPass := s.Pass
        smtpUser := s.User
        to := email
        smtpHost := s.Host
        smtpPort := s.Port

        var body bytes.Buffer

        if err := tmpl.ExecuteTemplate(&amp;body, emailTemp, data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">m := gomail.NewMessage()

        m.SetHeader("From", from)
        m.SetHeader("To", to)
        m.SetHeader("Subject", data.Subject)
        m.SetBody("text/html", body.String())
        m.AddAlternative("text/plain", html2text.HTML2Text(body.String()))

        d := gomail.NewDialer(smtpHost, smtpPort, smtpUser, smtpPass)
        d.TLSConfig = &amp;tls.Config{InsecureSkipVerify: true}

        return d.DialAndSend(m)</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package validate

import (
        "net/http"

        "github.com/go-playground/validator"
        "github.com/labstack/echo/v4"
)

type HttpValidator struct {
        validator *validator.Validate
}

func (hv *HttpValidator) Validate(i any) error <span class="cov0" title="0">{
        if err := hv.validator.Struct(i); err != nil </span><span class="cov0" title="0">{
                // Optionally, you could return the error to give each route more control over the status code
                return echo.NewHTTPError(http.StatusBadRequest, err.Error())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func NewHttpValidator(val *validator.Validate) *HttpValidator <span class="cov0" title="0">{
        return &amp;HttpValidator{validator: val}
}</span>
</pre>
		
		<pre class="file" id="file74" style="display: none">package integration

import (
        "bytes"
        "encoding/json"
        "io"
        "net/http"
        "testing"
        "time"

        "github.com/gorilla/websocket"
)

type HTTPClient struct {
        HTTPClient *http.Client
        AuthToken  string
}

func NewHTTPClient() *HTTPClient <span class="cov1" title="1">{
        return &amp;HTTPClient{
                HTTPClient: &amp;http.Client{
                        Timeout: 30 * time.Second,
                        Transport: &amp;http.Transport{
                                MaxIdleConns:       10,
                                IdleConnTimeout:    30 * time.Second,
                                DisableCompression: true,
                        },
                },
        }
}</span>

func (c *HTTPClient) Request(
        t *testing.T,
        method, url string,
        body any,
) (*http.Response, []byte) <span class="cov6" title="4">{
        t.Helper()

        var reqBody io.Reader
        if body != nil </span><span class="cov6" title="4">{
                jsonBody, err := json.Marshal(body)

                if err != nil </span><span class="cov0" title="0">{
                        t.Error(err)
                }</span>
                <span class="cov6" title="4">reqBody = bytes.NewBuffer(jsonBody)</span>
        }

        <span class="cov6" title="4">req, err := http.NewRequest(method, url, reqBody)
        if err != nil </span><span class="cov0" title="0">{
                t.Error(err)
        }</span>

        <span class="cov6" title="4">req.Header.Set("Content-Type", "application/json")
        if c.AuthToken != "" </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", c.AuthToken)
        }</span>

        <span class="cov6" title="4">resp, err := c.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                t.Error(err)
        }</span>
        <span class="cov6" title="4">defer resp.Body.Close()

        respBody, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                t.Error(err)
        }</span>

        <span class="cov6" title="4">return resp, respBody</span>
}

func (c *HTTPClient) GET(t *testing.T, url string) []byte <span class="cov0" title="0">{
        _, body := c.Request(t, "GET", url, nil)
        return body
}</span>

func (c *HTTPClient) POST(t *testing.T, url string, data interface{}) (*http.Response, []byte) <span class="cov6" title="4">{
        return c.Request(t, "POST", url, data)
}</span>

type WSClient struct {
        AuthToken string
        Conn      *websocket.Conn
}

func NewWSClient(authToken string) *WSClient <span class="cov6" title="4">{
        return &amp;WSClient{
                AuthToken: authToken,
        }
}</span>

func (c *WSClient) Connect(t *testing.T, url string) <span class="cov6" title="4">{
        t.Helper()

        headers := http.Header{}
        headers.Set("Authorization", c.AuthToken)

        dialer := websocket.Dialer{
                HandshakeTimeout: 10 * time.Second,
        }

        conn, resp, err := dialer.Dial(url, headers)
        if err != nil </span><span class="cov0" title="0">{
                t.Error("WebSocket connection failed", err)

        }</span>

        <span class="cov6" title="4">if http.StatusSwitchingProtocols != resp.StatusCode </span><span class="cov0" title="0">{
                t.Error("Status code should be 101 (SwitchingProtocols)")
        }</span>

        <span class="cov6" title="4">c.Conn = conn</span>
}

func (c *WSClient) Send(t *testing.T, message any) <span class="cov6" title="5">{
        t.Helper()

        if c.Conn == nil </span><span class="cov0" title="0">{
                t.Error("WebSocket connection is not established")
        }</span>

        <span class="cov6" title="5">var msgBytes []byte
        switch v := message.(type) </span>{
        case string:<span class="cov0" title="0">
                msgBytes = []byte(v)</span>
        case []byte:<span class="cov6" title="5">
                msgBytes = v</span>
        default:<span class="cov0" title="0">
                jsonMsg, err := json.Marshal(message)
                if err != nil </span><span class="cov0" title="0">{
                        t.Error(err)
                }</span>
                <span class="cov0" title="0">msgBytes = jsonMsg</span>
        }

        <span class="cov6" title="5">err := c.Conn.WriteMessage(websocket.TextMessage, msgBytes)
        if err != nil </span><span class="cov0" title="0">{
                t.Error(err)
        }</span>
}

func (c *WSClient) Receive(t *testing.T, timeout time.Duration) ([]byte, error) <span class="cov10" title="12">{
        t.Helper()

        if c.Conn == nil </span><span class="cov0" title="0">{
                t.Error("WebSocket connection is not established")
        }</span>

        <span class="cov10" title="12">if timeout &gt; 0 </span><span class="cov10" title="12">{
                c.Conn.SetReadDeadline(time.Now().Add(timeout))
                defer c.Conn.SetReadDeadline(time.Time{})
        }</span>

        <span class="cov10" title="12">_, message, err := c.Conn.ReadMessage()
        return message, err</span>
}

func (c *WSClient) Close(t *testing.T) <span class="cov3" title="2">{
        t.Helper()
        if c.Conn != nil </span><span class="cov3" title="2">{
                err := c.Conn.WriteMessage(websocket.CloseMessage,
                        websocket.FormatCloseMessage(websocket.CloseNormalClosure, ""))
                if err != nil </span><span class="cov0" title="0">{
                        t.Error(err)
                }</span>
                <span class="cov3" title="2">c.Conn.Close()</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
